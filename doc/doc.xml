<haxe>
	<class path="Array" params="T" file="C:\HaxeToolkit\haxe\std/Array.hx" extern="1">
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of `a` to the elements of
		`this` Array.

		This operation does not modify `this` Array.

		If `a` is the empty Array `[]`, a copy of `this` Array is returned.

		The length of the returned Array is equal to the sum of `this.length`
		and `a.length`.

		If `a` is `null`, the result is unspecified.</haxe_doc>
		</concat>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.

		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`

		If `this` is the empty Array `[]`, the result is the empty String `""`.
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.

		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the last element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this.length` will decrease by 1.

		If `this` is the empty Array `[]`, null is returned and the length
		remains 0.</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the new
		length of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<reverse public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[Reverse the order of elements of `this` Array.

		This operation modifies `this` Array in place.

		If `this.length < 2`, `this` remains unchanged.]]></haxe_doc>
		</reverse>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the first element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this`.length and the index of each
		remaining element is decreased by 1.

		If `this` is the empty Array `[]`, `null` is returned and the length
		remains 0.</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of `this` Array, starting at and
		including `pos`, up to but not including `end`.

		This operation does not modify `this` Array.

		The elements are not copied and retain their identity.

		If `end` is omitted or exceeds `this.length`, it defaults to the end of
		`this` Array.

		If `pos` or `end` are negative, their offsets are calculated from the
		end	of `this` Array by `this.length + pos` and `this.length + end`
		respectively. If this yields a negative value, 0 is used instead.

		If `pos` exceeds `this.length` or if `end` exceeds or equals `pos`,
		the result is `[]`.</haxe_doc>
		</slice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts `this` Array according to the comparison function `f`, where
		`f(x,y)` returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.

		This operation modifies `this` Array in place.

		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, `haxe.ds.sort.MergeSort.sort()` can be used instead.

		If `f` is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<splice public="1" set="method">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes `len` elements from `this` Array, starting at and including
		`pos`, an returns them.

		This operation modifies `this` Array in place.

		If `len` is < 0 or `pos` exceeds `this`.length, the result is the empty
		Array [].

		If `pos` is negative, its value is calculated from the end	of `this`
		Array by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the sum of the resulting values for `len` and `pos` exceed
		`this.length`, this operation will affect the elements from `pos` to the
		end of `this` Array.

		The length of the returned Array is equal to the new length of `this`
		Array subtracted from the original length of `this` Array. In other
		words, each element of the original `this` Array either remains in
		`this` Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Array.

		The result will include the individual elements' String representations
		separated by comma. The enclosing [ ] may be missing on some platforms,
		use Std.string() to get a String representation that is consistent
		across platforms.</haxe_doc>
		</toString>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the element `x` at the start of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` and the index of each Array element increases by 1.</haxe_doc>
		</unshift>
		<insert public="1" set="method">
			<f a="pos:x">
				<x path="Int"/>
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts the element `x` at the position `pos`.

		This operation modifies `this` Array in place.

		The offset is calculated like so:

		- If `pos` exceeds `this.length`, the offset is `this.length`.
		- If `pos` is negative, the offset is calculated from the end of `this`
		  Array, i.e. `this.length + pos`. If this yields a negative value, the
		  offset is 0.
		- Otherwise, the offset is `pos`.

		If the resulting offset does not exceed `this.length`, all elements from
		and including that offset to the end of `this` Array are moved one index
		ahead.</haxe_doc>
		</insert>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurence of `x` in `this` Array.

		This operation modifies `this` Array in place.

		If `x` is found by checking standard equality, it is removed from `this`
		Array and all following elements are reindexed acoordingly. The function
		then returns true.

		If `x` is not found, `this` Array is not changed and the function
		returns false.</haxe_doc>
		</remove>
		<indexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the first occurense of `x` in `this` Array, searching front to back.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with zero index. If it is negative, it will be taken as the
		offset from the end of `this` Array to compute the starting index. If given or computed
		starting index is less than 0, the whole array will be searched, if it is greater than
		or equal to the length of `this` Array, the function returns -1.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the last occurense of `x` in `this` Array, searching back to front.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with the last element index. If it is negative, it will be
		taken as the offset from the end of `this` Array to compute the starting index. If
		given or computed starting index is greater than or equal to the length of `this` Array,
		the whole array will be searched, if it is less than 0, the function returns -1.</haxe_doc>
		</lastIndexOf>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a shallow copy of `this` Array.

		The elements are not copied and retain their identity, so
		`a[i] == a.copy()[i]` is true for any valid `i`. However,
		`a == a.copy()` is always false.</haxe_doc>
		</copy>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="Array.T"/></t></f>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<map public="1" params="S" set="method">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<c path="map.S"/>
				</f>
				<c path="Array"><c path="map.S"/></c>
			</f>
			<haxe_doc>Creates a new Array by applying function `f` to all elements of `this`.

		The order of elements is preserved.

		If `f` is null, the result is unspecified.</haxe_doc>
		</map>
		<filter public="1" set="method">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<x path="Bool"/>
				</f>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns an Array containing those elements of `this` for which `f`
		returned true.

		The individual elements are not duplicated and retain their identity.

		If `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API.</haxe_doc>
	</class>
	<abstract path="Class" params="T" file="C:\HaxeToolkit\haxe\std/Class.hx">
		<this><x path="Class"><c path="Class.T"/></x></this>
		<haxe_doc>An abstract type that represents a Class.

	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="Date" params="" file="C:\HaxeToolkit\haxe\std/Date.hx" extern="1">
		<now public="1" set="method" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>Returns a Date representing the current local time.</haxe_doc>
		</now>
		<fromTime public="1" set="method" static="1">
			<f a="t">
				<x path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from timestamp `t`.</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from a formated string `s`, with the following accepted
		formats:

		- `"YYYY-MM-DD hh:mm:ss"`
		- `"YYYY-MM-DD"`
		- `"hh:mm:ss"`

		The first two formats are expressed in local time, the third in UTC
		Epoch.</haxe_doc>
		</fromString>
		<getTime public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the timestamp of the date. It might only have a per-second
		precision depending on the platforms.</haxe_doc>
		</getTime>
		<getHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours of `this` Date (0-23 range).</haxe_doc>
		</getHours>
		<getMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes of `this` Date (0-59 range).</haxe_doc>
		</getMinutes>
		<getSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds of the `this` Date (0-59 range).</haxe_doc>
		</getSeconds>
		<getFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the full year of `this` Date (4-digits).</haxe_doc>
		</getFullYear>
		<getMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month of `this` Date (0-11 range).</haxe_doc>
		</getMonth>
		<getDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of `this` Date (1-31 range).</haxe_doc>
		</getDate>
		<getDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week of `this` Date (0-6 range).</haxe_doc>
		</getDay>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See `DateTools.format` for
		other formating rules.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="year:month:day:hour:min:sec">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new date object from the given arguments.

		The behaviour of a Date instance is only consistent across platforms if
		the the arguments describe a valid date.

		- month: 0 to 11
		- day: 1 to 31
		- hour: 0 to 23
		- min: 0 to 59
		- sec: 0 to 59</haxe_doc>
		</new>
		<haxe_doc>The Date class provides a basic structure for date and time related
	information. Date instances can be created by

	- `new Date()` for a specific date,
	- `Date.now()` to obtain information about the current time,
	- `Date.fromTime()` with a given timestamp or
	- `Date.fromString()` by parsing from a String.

	There is some extra functions available in the `DateTools` class.

	In the context of haxe dates, a timestamp is defined as the number of
	milliseconds elapsed since 1st January 1970.</haxe_doc>
	</class>
	<class path="EReg" params="" file="C:\HaxeToolkit\haxe\std/flash/_std/EReg.hx">
		<r><c path="flash.utils.RegExp"/></r>
		<result><c path="+Array"/></result>
		<match public="1" set="method" line="31">
			<f a="s">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `this` regular expression matches String `s`.

		This method modifies the internal state.

		If `s` is `null`, the result is unspecified.</haxe_doc>
		</match>
		<matched public="1" set="method" line="37">
			<f a="n">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the matched sub-group `n` of `this` EReg.

		This method should only be called after `this.match` or
		`this.matchSub`, and then operates on the String of that operation.

		The index `n` corresponds to the n-th set of parentheses in the pattern
		of `this` EReg. If no such sub-group exists, an exception is thrown.

		If `n` equals 0, the whole matched substring is returned.</haxe_doc>
		</matched>
		<new public="1" set="method" line="27">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new regular expression with pattern `r` and modifiers `opt`.

		This is equivalent to the shorthand syntax `~/r/opt`

		If `r` or `opt` are null, the result is unspecified.</haxe_doc>
		</new>
		<haxe_doc>The EReg class represents regular expressions.

	While basic usage and patterns consistently work across platforms, some more
	complex operations may yield different results. This is a necessary trade-
	off to retain a certain level of performance.

	EReg instances can be created by calling the constructor, or with the
	special syntax ~/pattern/modifier

	EReg instances maintain an internal state, which is affected by several of
	its methods.

	A detailed explanation of the supported operations is available at
	http://haxe.org/doc/cross/regexp</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Enum" params="T" file="C:\HaxeToolkit\haxe\std/Enum.hx">
		<this><x path="Enum"><c path="Enum.T"/></x></this>
		<haxe_doc>An abstract type that represents an Enum type.

	The corresponding enum instance type is `EnumValue`.

	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="C:\HaxeToolkit\haxe\std/EnumValue.hx">
		<this><x path="EnumValue"/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<class path="Lambda" params="" file="C:\HaxeToolkit\haxe\std/Lambda.hx">
		<has public="1" params="A" set="method" line="98" static="1">
			<f a="it:elt">
				<t path="Iterable"><c path="has.A"/></t>
				<c path="has.A"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `it` contains `elt`.

		This function returns true as soon as an element is found which is equal
		to `elt` according to the `==` operator.

		If no such element is found, the result is false.</haxe_doc>
		</has>
		<indexOf public="1" params="T" set="method" line="217" static="1">
			<f a="it:v">
				<t path="Iterable"><c path="indexOf.T"/></t>
				<c path="indexOf.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of the first element `v` within Iterable `it`.

		This function uses operator `==` to check for equality.

		If `v` does not exist in `it`, the result is -1.</haxe_doc>
		</indexOf>
		<find public="1" params="T" set="method" line="237" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="find.T"/></t>
				<f a="">
					<c path="find.T"/>
					<x path="Bool"/>
				</f>
				<t path="Null"><c path="find.T"/></t>
			</f>
			<haxe_doc>Returns the first element of `it` for which `f` is true.

		This function returns as soon as an element is found for which a call to
		`f` returns true.

		If no such element is found, the result is null.

		If `f` is null, the result is unspecified.</haxe_doc>
		</find>
		<haxe_doc>The `Lambda` class is a collection of methods to support functional
	programming. It is ideally used with 'using Lambda' and then acts as an
	extension to Iterable types.

	On static platforms, working with the Iterable structure might be slower
	than performing the operations directly on known types, such as Array and
	List.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="List" params="T" file="C:\HaxeToolkit\haxe\std/List.hx">
		<h><c path="Array"><d/></c></h>
		<q><c path="Array"><d/></c></q>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` List.</haxe_doc>
		</length>
		<push public="1" set="method" line="64">
			<f a="item">
				<c path="List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the beginning of `this` List.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<remove public="1" set="method" line="138">
			<f a="v">
				<c path="List.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurence of `v` in `this` List.

		If `v` is found by checking standard equality, it is removed from `this`
		List and the function returns true.

		Otherwise, false is returned.</haxe_doc>
		</remove>
		<iterator public="1" set="method" line="161">
			<f a=""><t path="Iterator"><c path="List.T"/></t></f>
			<haxe_doc>Returns an iterator on the elements of the list.</haxe_doc>
		</iterator>
		<new public="1" set="method" line="40">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. The list is composed of two-elements arrays
	that are chained together. It is optimized so that adding or removing an
	element does not imply copying the whole array content every time.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<abstract path="Map" params="K:V" file="C:\HaxeToolkit\haxe\std/Map.hx">
		<from>
			<icast field="fromStringMap"><c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c></icast>
			<icast field="fromIntMap"><c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c></icast>
			<icast field="fromObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="fromObjectMap.K"/>
	<c path="fromObjectMap.V"/>
</c></icast>
		</from>
		<this><c path="IMap">
	<c path="Map.K"/>
	<c path="Map.V"/>
</c></this>
		<to>
			<icast field="toStringMap"><c path="haxe.ds.StringMap"><c path="Map.V"/></c></icast>
			<icast field="toIntMap"><c path="haxe.ds.IntMap"><c path="Map.V"/></c></icast>
			<icast field="toEnumValueMapMap"><c path="haxe.ds.EnumValueMap">
	<c path="toEnumValueMapMap.K"/>
	<c path="Map.V"/>
</c></icast>
			<icast field="toObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="toObjectMap.K"/>
	<c path="Map.V"/>
</c></icast>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.

	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.

	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.

	Maps can also be created with `key1 => value1, key2 => value2` syntax.

	Map is an abstract type, it is not available at runtime.]]></haxe_doc>
		<meta><m n=":multiType"><e>K</e></m></meta>
		<impl><class path="_Map.Map_Impl_" params="" file="C:\HaxeToolkit\haxe\std/Map.hx" private="1" module="Map"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="IMap" params="K:V" file="C:\HaxeToolkit\haxe\std/Map.hx" module="Map" interface="1"><meta><m n=":keep"/></meta></class>
	<typedef path="_Map.Hashable" params="" file="C:\HaxeToolkit\haxe\std/Map.hx" private="1" module="Map"><a><hashCode set="method"><f a=""><x path="Int"/></f></hashCode></a></typedef>
	<class path="Math" params="" file="C:\HaxeToolkit\haxe\std/Math.hx" extern="1">
		<PI public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>Represents the ratio of the circumference of a circle to its diameter, 
		specified by the constant, Ï€. `PI` is approximately 3.141592653589793.</haxe_doc>
		</PI>
		<NEGATIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes negative infinity.

		For example, this is the result of -1.0 / 0.0.

		Operations with NEGATIVE_INFINITY as an operand may result in
		NEGATIVE_INFINITY, POSITIVE_INFINITY or NaN. 

		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.</haxe_doc>
		</NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes negative infinity.

		For example, this is the result of 1.0 / 0.0.

		Operations with POSITIVE_INFINITY as an operand may result in
		NEGATIVE_INFINITY, POSITIVE_INFINITY or NaN. 

		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.</haxe_doc>
		</POSITIVE_INFINITY>
		<NaN public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes an invalid number.

		NaN stands for "Not a Number". It occurs when a mathematically incorrect
		operation is executed, such as taking the square root of a negative
		number: Math.sqrt(-1).

		All further operations with NaN as an operand will result in NaN.

		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.

		In order to test if a value is NaN, you should use Math.isNaN() function.

		@php In PHP versions prior to 5.3.1 VC 9 there may be unexpected
		results when performing arithmetic operations with NaN on Windows, 
		see [https://bugs.php.net/bug.php?id=42143]</haxe_doc>
		</NaN>
		<abs public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the absolute value of `v`.

		If `v` is positive or 0, the result is unchanged. Otherwise the result 
		is -`v`.
		
		If `v` is NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is 
		POSITIVE_INFINITY.
		
		If `v` is NaN, the result is NaN.</haxe_doc>
		</abs>
		<min public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smaller of values `a` and `b`.

		If `a` or `b` are NaN, the result is NaN.
		If `a` or `b` are NEGATIVE_INFINITY, the result is NEGATIVE_INFINITY.
		If `a` and `b` are POSITIVE_INFINITY, the result is POSITIVE_INFINITY.</haxe_doc>
		</min>
		<max public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the greater of values `a` and `b`.

		If `a` or `b` are NaN, the result is NaN.
		If `a` or `b` are POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		If `a` and `b` are NEGATIVE_INFINITY, the result is NEGATIVE_INFINITY.</haxe_doc>
		</max>
		<sin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric sine of the specified angle `v`, in radians.
		
		If `v` is NaN or infinite, the result is NaN.</haxe_doc>
		</sin>
		<cos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric cosine of the specified angle `v`, in radians.
		
		If `v` is NaN or infinite, the result is NaN.</haxe_doc>
		</cos>
		<tan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric tangent of the specified angle `v`, in radians.
		
		If `v` is NaN or infinite, the result is NaN.</haxe_doc>
		</tan>
		<asin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc of the specified angle `v`, in radians.
		
		If `v` is NaN or infinite, the result is NaN.</haxe_doc>
		</asin>
		<acos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc cosine of the specified angle `v`, 
		in radians.
		
		If `v` is NaN or infinite, the result is NaN.</haxe_doc>
		</acos>
		<atan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent of the specified angle `v`, 
		in radians.
		
		If `v` is NaN or infinite, the result is NaN.</haxe_doc>
		</atan>
		<atan2 public="1" set="method" static="1">
			<f a="y:x">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent whose tangent is the quotient of 
		two specified numbers, in radians.
		
		If parameter `x` or `y`  is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, 
		the result is NaN.</haxe_doc>
		</atan2>
		<exp public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns Euler's number, raised to the power of `v`.
		
		exp(1.0) is approximately 2.718281828459.
		
		If `v` is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		If `v` is NEGATIVE_INFINITY, the result is 0.0.
		If `v` is NaN, the result is NaN.</haxe_doc>
		</exp>
		<log public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the natural logarithm of `v`.
		
		This is the mathematical inverse operation of exp, 
		i.e. `log(exp(v)) == v` always holds.
		
		If `v` is negative (including NEGATIVE_INFINITY) or NaN, the result 
		is NaN.
		If `v` is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		If `v` is 0.0, the result is NEGATIVE_INFINITY.</haxe_doc>
		</log>
		<pow public="1" set="method" static="1">
			<f a="v:exp">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns a specified base `v` raised to the specified power `exp`.</haxe_doc>
		</pow>
		<sqrt public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the square root of `v`.
		
		If `v` is negative (including NEGATIVE_INFINITY) or NaN, the result 
		is NaN.
		If `v` is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		If `v` is 0.0, the result is 0.0.</haxe_doc>
		</sqrt>
		<round public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest integer value.
		
		If `v` is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY 
		or POSITIVE_INFINITY, the result is unspecified.</haxe_doc>
		</round>
		<floor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the largest integer value that is not greater than `v`.

		If `v` is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY 
		or POSITIVE_INFINITY, the result is unspecified.</haxe_doc>
		</floor>
		<ceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the smallest integer value that is not less than `v`.

		If `v` is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY 
		or POSITIVE_INFINITY, the result is unspecified.</haxe_doc>
		</ceil>
		<random public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a pseudo-random number which is greater than or equal to 0.0, 
		and less than 1.0.</haxe_doc>
		</random>
		<ffloor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the largest integer value that is not greater than `v`, as a Float.

		If `v` is is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, 
		the result is unspecified.</haxe_doc>
		</ffloor>
		<fceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smallest integer value that is not less than `v`, as a Float.

		If `v` is is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, 
		the result is unspecified.</haxe_doc>
		</fceil>
		<fround public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest integer value, as a Float.

		If `v` is is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, 
		the result is unspecified.</haxe_doc>
		</fround>
		<isFinite public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is a finite number.

		If `f` is POSITIVE_INFINITY, NEGATIVE_INFINITY or NaN, the result 
		is false, otherwise the result is true.</haxe_doc>
		</isFinite>
		<isNaN public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is not a valid number.

		If `f` is NaN, the result is true, otherwise the result is false. 
		In particular, both POSITIVE_INFINITY and NEGATIVE_INFINITY are
		not considered NaN.</haxe_doc>
		</isNaN>
		<haxe_doc>This class defines mathematical functions and constants.</haxe_doc>
	</class>
	<class path="Reflect" params="" file="C:\HaxeToolkit\haxe\std/flash/_std/Reflect.hx">
		<field public="1" set="method" line="28" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the value of the field named `field` on object `o`.

		If `o` is not an object or has no field named `field`, the result is
		null.

		If the field is defined as a property, its accessors are ignored. Refer
		to `Reflect.getProperty` for a function supporting property accessors.

		If `field` is null, the result is unspecified.

		(As3) If used on a property field, the getter will be invoked. It is
		not possible to obtain the value directly.</haxe_doc>
		</field>
		<fields public="1" set="method" line="59" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the fields of structure `o`.

		This method is only guaranteed to work on anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` is null, the result is unspecified.</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="82" static="1">
			<f a="f">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if `f` is a function, false otherwise.

		If `f` is null, the result is false.</haxe_doc>
		</isFunction>
		<isObject public="1" set="method" line="96" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[Tells if `v` is an object.

		The result is true if `v` is one of the following:

		- class instance
		- structure
		- Class<T>
		- Enum<T>

		Otherwise, including if `v` is null, the result is false.]]></haxe_doc>
		</isObject>
		<isEnumValue public="1" set="method" line="106" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `v` is an enum value.

		The result is true if `v` is of type EnumValue, i.e. an enum
		constructor.

		Otherwise, including if `v` is null, the result is false.</haxe_doc>
		</isEnumValue>
		<haxe_doc>The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Std" params="" file="C:\HaxeToolkit\haxe\std/flash/_std/Std.hx">
		<is public="1" set="method" line="26" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if a value v is of the type t. Returns false if v or t are null.</haxe_doc>
		</is>
		<string public="1" set="method" line="34" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<parseInt public="1" set="method" line="42" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<haxe_doc>Converts a `String` to an `Int`.

		Leading whitespaces are ignored.

		If `x` starts with 0x or 0X, hexadecimal notation is recognized where the following digits may
		contain 0-9 and A-F.

		Otherwise `x` is read as decimal number with 0-9 being allowed characters. `x` may also start with
		a - to denote a negative value.

		In decimal mode, parsing continues until an invalid character is detected, in which case the
		result up to that point is returned. For hexadecimal notation, the effect of invalid characters
		is unspecified.

		Leading 0s that are not part of the 0x/0X hexadecimal notation are ignored, which means octal
		notation is not supported.

		If the input cannot be recognized, the result is null.</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="49" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Converts a `String` to a `Float`.

		The parsing rules for `parseInt` apply here as well, with the exception of invalid input
		resulting in a NaN value instead of null.

		Additionally, decimal notation may contain a single `.` to denote the start of the fractions.</haxe_doc>
		</parseFloat>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Void" params="" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Void"/></this>
		<haxe_doc>The standard Void type. Only `null` values can be of the type `Void`.</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Float"/></this>
		<haxe_doc><![CDATA[The standard Float type, this is a double-precision IEEE 64bit float.

	On static targets, null cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Int"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard Int type. Its precision depends on the platform.

	On static targets, null cannot be assigned to Int. If this is necessary,
	`Null<Int>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Null" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>`Null` can be useful in two cases. In order to document some methods
	that accepts or can return a `null` value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.</haxe_doc>
	</typedef>
	<abstract path="Bool" params="" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Bool"/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be true or false.

	On static targets, null cannot be assigned to Bool. If this is necessary,
	`Null<Bool>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Dynamic"><c path="Dynamic.T"/></x></this>
		<haxe_doc>Dynamic is a special type which is compatible with all other types.

	Use of Dynamic should be minimized as it prevents several compiler
	checks and optimizations.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the Iterator and advances to the next one.

		This method is not required to check hasNext() first. A call to this
		method while hasNext() is false yields unspecified behavior.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns false if the iteration is complete, true otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to next(). However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An Iterator is a structure that permits iteration over elements of type T.

	Any class with matching hasNext and next fields is considered an Iterator
	and can then be used e.g. in for-loops. This makes it easy to implement
	custom iterators.</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An Iterable is a data structure which has an iterator() method.
	See `Lambda` for generic functions on iterable structures.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.</haxe_doc></class>
	<class path="String" params="" file="C:\HaxeToolkit\haxe\std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code `code`.

		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.

		Affects the characters `a-z`. Other characters remain unchanged.</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.

		Affects the characters `A-Z`. Other characters remain unchanged.</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, the empty String ""
		is returned.</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<haxe_doc>Returns the character code at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, null is returned.

		To obtain the character code of a single character, "x".code can be used
		instead to inline the character code at compile time. Note that this
		only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits `this` String at each occurence of `delimiter`.

		If `this` String is the empty String "", the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.

		If `delimiter` is the empty String "", `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.

		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.

		If `delimiter` is null, the result is unspecified.

		Otherwise, `this` String is split into parts at each occurence of
		`delimiter`. If `this` String starts (or ends) with [delimiter}, the
		result Array contains a leading (or trailing) empty String "" element.
		Two subsequent delimiters also result in an empty String "" element.</haxe_doc>
		</split>
		<substr public="1" set="method">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.

		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.

		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.

		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to `endIndex`.

		If `startIndex` or `endIndex` are negative, 0 is used instead.

		If `startIndex` exceeds `endIndex`, they are swapped.

		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.

		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String "" is returned.</haxe_doc>
		</substring>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.

	A haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.

	Strings can be constructed using the string literal syntax "string value".

	String can be concatenated by using the + operator. If an operand is not a
	String, it is passed through Std.string() first.</haxe_doc>
	</class>
	<class path="StringBuf" params="" file="C:\HaxeToolkit\haxe\std/StringBuf.hx">
		<b><c path="String"/></b>
		<new public="1" set="method" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringBuf instance.

		This may involve initialization of the internal buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by appending small
	elements together.

	Its cross-platform implementation uses String concatenation internally, but
	StringBuf may be optimized for different targets.

	Unlike String, an instance of StringBuf is not immutable in the sense that
	it can be passed as argument to functions which modify it by appending more
	values. However, the internal buffer cannot be modified.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="StringTools" params="" file="C:\HaxeToolkit\haxe\std/StringTools.hx">
		<lpad public="1" set="method" line="248" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Concatenates `c` to `s` until `s.length` is at least `l`.

		If `c` is the empty String "" or if `l` does not exceed `s.length`,
		`s` is returned unchanged.

		If `c.length` is 1, the resulting String length is exactly `l`.

		Otherwise the length may exceed `l`.

		If `c` is null, the result is unspecified.</haxe_doc>
		</lpad>
		<haxe_doc>This class provides advanced methods on Strings. It is ideally used with
	'using StringTools' and then acts as an extension to the String class.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<enum path="ValueType" params="" file="C:\HaxeToolkit\haxe\std/flash/_std/Type.hx" module="Type">
		<TNull/>
		<TInt/>
		<TFloat/>
		<TBool/>
		<TObject/>
		<TFunction/>
		<TClass a="c"><x path="Class"><d/></x></TClass>
		<TEnum a="e"><x path="Enum"><d/></x></TEnum>
		<TUnknown/>
	</enum>
	<class path="Type" params="" file="C:\HaxeToolkit\haxe\std/flash/_std/Type.hx">
		<getClass public="1" params="T" set="method" line="36" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<x path="Class"><c path="getClass.T"/></x>
			</f>
			<haxe_doc>Returns the class of `o`, if `o` is a class instance.

		If `o` is null or of a different type, null is returned.

		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getClass>
		<createInstance public="1" params="T" set="method" line="130" static="1">
			<f a="cl:args">
				<x path="Class"><c path="createInstance.T"/></x>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class `cl`, using `args` as arguments to the
		class constructor.

		This function guarantees that the class constructor is called.

		Default values of constructors arguments are not guaranteed to be
		taken into account.

		If `cl` or `args` are null, or if the number of elements in `args` does
		not match the expected number of constructor arguments, or if any
		argument has an invalid type,  or if `cl` has no own constructor, the
		result is unspecified.

		In particular, default values of constructor arguments are not
		guaranteed to be taken into account.</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" line="151" static="1">
			<f a="cl">
				<x path="Class"><c path="createEmptyInstance.T"/></x>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class `cl`.

		This function guarantees that the class constructor is not called.

		If `cl` is null, the result is unspecified.</haxe_doc>
		</createEmptyInstance>
		<describe set="method" line="182" static="1"><f a="t:fact">
	<d/>
	<x path="Bool"/>
	<c path="Array"><c path="String"/></c>
</f></describe>
		<getInstanceFields public="1" set="method" line="199" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the instance fields of class `c`.

		This only includes fields which are known at compile-time. In
		particular, using getInstanceFields(getClass(obj)) will not include
		any fields which were added to obj at runtime.

		The order of the fields in the returned Array is unspecified.

		If `c` is null, the result is unspecified.

		(As3) This method only returns instance fields that are public.</haxe_doc>
		</getInstanceFields>
		<typeof public="1" set="method" line="215" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>Returns the runtime type of value `v`.

		The result corresponds to the type `v` has at runtime, which may vary
		per platform. Assumptions regarding this should be minimized to avoid
		surprises.</haxe_doc>
		</typeof>
		<haxe_doc>The haxe Reflection API allows retrieval of type information at runtime.

	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="UInt" params="" file="C:\HaxeToolkit\haxe\std/UInt.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="UInt"/></this>
		<to><icast><x path="Int"/></icast></to>
		<haxe_doc>The unsigned Int type is only defined for Flash9 and C#. It's currently
	handled the same as a normal Int.</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="dl.input.Keys" params="" file="src/dl/input/Keyboard.hx" module="dl.input.Keyboard">
		<from><icast field="fromInt"><x path="UInt"/></icast></from>
		<this><x path="UInt"/></this>
		<to><icast field="toUInt"><x path="UInt"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="dl.input._Keyboard.Keys_Impl_" params="" file="src/dl/input/Keyboard.hx" private="1" module="dl.input.Keyboard">
	<keyLeft public="1" get="inline" set="null" line="9" static="1">
		<x path="dl.input.Keys"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</keyLeft>
	<keyRight public="1" get="inline" set="null" line="10" static="1">
		<x path="dl.input.Keys"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</keyRight>
	<keyTop public="1" get="inline" set="null" line="11" static="1">
		<x path="dl.input.Keys"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</keyTop>
	<keyBottom public="1" get="inline" set="null" line="12" static="1">
		<x path="dl.input.Keys"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</keyBottom>
	<keyB1 public="1" get="inline" set="null" line="13" static="1">
		<x path="dl.input.Keys"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</keyB1>
	<keyB2 public="1" get="inline" set="null" line="14" static="1">
		<x path="dl.input.Keys"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</keyB2>
	<keyStart public="1" get="inline" set="null" line="15" static="1">
		<x path="dl.input.Keys"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</keyStart>
	<keySelect public="1" get="inline" set="null" line="16" static="1">
		<x path="dl.input.Keys"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</keySelect>
	<_new get="inline" set="null" line="18" static="1">
		<f a="i">
			<x path="UInt"/>
			<x path="UInt"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<fromInt public="1" set="method" line="21" static="1">
		<f a="i">
			<x path="UInt"/>
			<x path="dl.input.Keys"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromInt>
	<toUInt public="1" set="method" line="26" static="1">
		<f a="this">
			<x path="UInt"/>
			<x path="UInt"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toUInt>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="dl.input._Keyboard.Keys_Impl_" params="" file="src/dl/input/Keyboard.hx" private="1" module="dl.input.Keyboard">
		<keyLeft public="1" get="inline" set="null" line="9" static="1">
			<x path="dl.input.Keys"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</keyLeft>
		<keyRight public="1" get="inline" set="null" line="10" static="1">
			<x path="dl.input.Keys"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</keyRight>
		<keyTop public="1" get="inline" set="null" line="11" static="1">
			<x path="dl.input.Keys"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</keyTop>
		<keyBottom public="1" get="inline" set="null" line="12" static="1">
			<x path="dl.input.Keys"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</keyBottom>
		<keyB1 public="1" get="inline" set="null" line="13" static="1">
			<x path="dl.input.Keys"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</keyB1>
		<keyB2 public="1" get="inline" set="null" line="14" static="1">
			<x path="dl.input.Keys"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</keyB2>
		<keyStart public="1" get="inline" set="null" line="15" static="1">
			<x path="dl.input.Keys"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</keyStart>
		<keySelect public="1" get="inline" set="null" line="16" static="1">
			<x path="dl.input.Keys"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</keySelect>
		<_new get="inline" set="null" line="18" static="1">
			<f a="i">
				<x path="UInt"/>
				<x path="UInt"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<fromInt public="1" set="method" line="21" static="1">
			<f a="i">
				<x path="UInt"/>
				<x path="dl.input.Keys"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromInt>
		<toUInt public="1" set="method" line="26" static="1">
			<f a="this">
				<x path="UInt"/>
				<x path="UInt"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toUInt>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="dl.input.Keyboard" params="" file="src/dl/input/Keyboard.hx">
		<_listKeyPressed><c path="Array"><x path="UInt"/></c></_listKeyPressed>
		<_listKeyPressedTime><c path="Array"><x path="Float"/></c></_listKeyPressedTime>
		<_accTime><x path="Float"/></_accTime>
		<_menuEnabled><x path="Bool"/></_menuEnabled>
		<_onMenuPrev><f a="">
	<x path="dl.input.Keys"/>
	<x path="Void"/>
</f></_onMenuPrev>
		<_onMenuNext><f a="">
	<x path="dl.input.Keys"/>
	<x path="Void"/>
</f></_onMenuNext>
		<_onMenuValid><f a="">
	<x path="dl.input.Keys"/>
	<x path="Void"/>
</f></_onMenuValid>
		<_onMenuCancel><f a="">
	<x path="dl.input.Keys"/>
	<x path="Void"/>
</f></_onMenuCancel>
		<addListener public="1" set="method" line="61"><f a="onPrev:onNext:onValid:onCancel">
	<f a="">
		<x path="dl.input.Keys"/>
		<x path="Void"/>
	</f>
	<f a="">
		<x path="dl.input.Keys"/>
		<x path="Void"/>
	</f>
	<f a="">
		<x path="dl.input.Keys"/>
		<x path="Void"/>
	</f>
	<f a="">
		<x path="dl.input.Keys"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></addListener>
		<removeListener public="1" set="method" line="72"><f a=""><x path="Void"/></f></removeListener>
		<getAxisX public="1" get="inline" set="null" line="78"><f a=""><x path="Float"/></f></getAxisX>
		<getAxisY public="1" get="inline" set="null" line="85"><f a=""><x path="Float"/></f></getAxisY>
		<getB1 public="1" get="inline" set="null" line="92"><f a=""><x path="Float"/></f></getB1>
		<getB2 public="1" get="inline" set="null" line="97"><f a=""><x path="Float"/></f></getB2>
		<getStart public="1" get="inline" set="null" line="102"><f a=""><x path="Bool"/></f></getStart>
		<getSelect public="1" get="inline" set="null" line="107"><f a=""><x path="Bool"/></f></getSelect>
		<getKeyPressed public="1" get="inline" set="null" line="112"><f a="keyCode">
	<x path="UInt"/>
	<x path="Bool"/>
</f></getKeyPressed>
		<dispose public="1" set="method" line="117"><f a=""><x path="Void"/></f></dispose>
		<getFloat set="method" line="126"><f a="key">
	<x path="UInt"/>
	<x path="Float"/>
</f></getFloat>
		<keyDown set="method" line="137"><f a="e">
	<c path="flash.events.KeyboardEvent"/>
	<x path="Void"/>
</f></keyDown>
		<keyUp set="method" line="143"><f a="e">
	<c path="flash.events.KeyboardEvent"/>
	<x path="Void"/>
</f></keyUp>
		<new public="1" set="method" line="48"><f a="?accTimeSec" v="0.08f">
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Intermediate for keyboard inputs
 * 
 * @author Namide</haxe_doc>
	</class>
	<class path="dl.input.PlatformPlayerController" params="" file="src/dl/input/PlatformPlayerController.hx">
		<extends path="dl.input.Keyboard"/>
		<getVX public="1" get="inline" set="null" line="241" static="1"><f a="pxBySec:frameDelay">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></getVX>
		<getJumpStartVY public="1" get="inline" set="null" line="246" static="1"><f a="jumpPx:gravity">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></getJumpStartVY>
		<getJumpVY public="1" get="inline" set="null" line="251" static="1"><f a="maxPxJump:jumpStartVY:gravity">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></getJumpVY>
		<getJumpVX public="1" get="inline" set="null" line="256" static="1"><f a="maxPxJump:jumpStartVY:?jumpVY:gravity" v="::0:">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></getJumpVX>
		<maxPxYJump set="method" line="261" static="1"><f a="maxPxXJump:jumpStartVY:jumpVX:jumpVY:gravity">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></maxPxYJump>
		<maxPxXJump set="method" line="282" static="1"><f a="maxPxYJump:jumpStartVY:jumpVX:jumpVY:gravity">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></maxPxXJump>
		<_fDelay><x path="Float"/></_fDelay>
		<_groundVX><x path="Float"/></_groundVX>
		<_jumpStartVY><x path="Float"/></_jumpStartVY>
		<_jumpVY><x path="Float"/></_jumpVY>
		<_jumpVXMin><x path="Float"/></_jumpVXMin>
		<_jumpVXMax><x path="Float"/></_jumpVXMax>
		<_jumpTimeLock><x path="Float"/></_jumpTimeLock>
		<_actionPressed><x path="Bool"/></_actionPressed>
		<_landmark><x path="Float"/></_landmark>
		<_body><c path="dl.physic.body.Body"/></_body>
		<init public="1" set="method" line="58"><f a="?runPxSec:?jumpHeightMin:?jumpHeightMax:?jumpLengthMin:?jumpLengthMax:?gravityY" v="384.f:48.f:96.f:96.f:192.f:2.0f">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></init>
		<setRun set="method" line="72"><f a="vel:accTime">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setRun>
		<setJump set="method" line="76"><f a="hMin:hMax:lMin:lMax:accTime:timeLock:g">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setJump>
		<update public="1" set="method" line="85"><f a="t">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<getMaxPxXJump public="1" get="inline" set="null" line="230"><f a="maxTilesXJump:gravity">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></getMaxPxXJump>
		<getMaxPxYJump public="1" get="inline" set="null" line="235"><f a="maxTilesYJump:gravity">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></getMaxPxYJump>
		<new public="1" set="method" line="47"><f a="body:?frameDelaySec" v=":0.02f">
	<c path="dl.physic.body.Body"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Namide</haxe_doc>
	</class>
	<class path="dl.physic.body.Body" params="" file="src/dl/physic/body/Body.hx">
		<SHAPE_PRINT_NUM public="1" line="17" static="1">
			<x path="Int"/>
			<haxe_doc>* Historic of positioning (number of memory). Minimal number is 2.
	 * If you add intermediates positionning you must increment SHAPE_PRINT_NUM.
	 * In example for multiplayer manipulation.</haxe_doc>
		</SHAPE_PRINT_NUM>
		<name public="1">
			<c path="String"/>
			<haxe_doc>* Optional data</haxe_doc>
		</name>
		<shape public="1">
			<c path="Array"><c path="dl.physic.body.Shape"/></c>
			<haxe_doc>* Delimit the shape of this body.
	* shape[0] is the current shape.
	* shape[1] is the last shape...</haxe_doc>
		</shape>
		<contacts public="1" set="null">
			<c path="dl.physic.contact.BodyContact"/>
			<haxe_doc>* Other body in contact with this one</haxe_doc>
		</contacts>
		<physic public="1" set="null">
			<c path="dl.physic.move.BodyPhysic"/>
			<haxe_doc>* Physic datas (velocity, mass...).
	 * Usable to calculate physic moves.</haxe_doc>
		</physic>
		<x public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* Position in X-axis in pixel</haxe_doc>
		</x>
		<y public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* Position in Y-axis in pixel</haxe_doc>
		</y>
		<moved public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>* True if the body has moved since the last frame.</haxe_doc>
		</moved>
		<setPos public="1" set="method" line="78">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Edits the position in pixel
	 * 
	 * @param	x		New X-axis position in pixel
	 * @param	y		New Y-axis position in pixel</haxe_doc>
		</setPos>
		<setX public="1" set="method" line="101">
			<f a="x">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Edits the X-axis in pixel
	 * 
	 * @param	x	New X-axis position in pixel</haxe_doc>
		</setX>
		<setY public="1" set="method" line="124">
			<f a="y">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Edits the Y-axis in pixel
	 * 
	 * @param	y	New Y-axis position in pixel</haxe_doc>
		</setY>
		<addPos public="1" set="method" line="148">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Add numbers to actual position.
	 * 
	 * @param	x		Number to add to the X-axis position in pixel
	 * @param	y		Number to add to the Y-axis position in pixel</haxe_doc>
		</addPos>
		<updateAABB public="1" set="method" line="171">
			<f a="?updatePrint" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Update the bounding box of this body.
	 * 
	 * @param	updatePrint		Force the saves of the datas</haxe_doc>
		</updateAABB>
		<addBodyContact public="1" get="inline" set="null" line="196">
			<f a="?flags" v="0">
				<x path="dl.physic.contact.BodyContactsFlags"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Initialize the BodyContacts property.
	 * 
	 * @param	flags		List of flags of the BodyContacts</haxe_doc>
		</addBodyContact>
		<addBodyPhysic public="1" get="inline" set="null" line="209">
			<f a="?flags" v="0">
				<x path="dl.physic.move.BodyPhysicFlags"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Initialize the BodyPhysic property.
	 * 
	 * @param	flags		List of flags of the BodyPhysic</haxe_doc>
		</addBodyPhysic>
		<new public="1" set="method" line="57"><f a="shape:?x:?y" v=":0:0">
	<c path="dl.physic.body.Shape"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Namide</haxe_doc>
	</class>
	<abstract path="dl.physic.body.ShapeType" params="" file="src/dl/physic/body/Shape.hx" module="dl.physic.body.Shape">
		<from><icast field="fromInt"><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast field="toInt"><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="dl.physic.body._Shape.ShapeType_Impl_" params="" file="src/dl/physic/body/Shape.hx" private="1" module="dl.physic.body.Shape">
	<point public="1" get="inline" set="null" line="7" static="1">
		<x path="dl.physic.body.ShapeType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</point>
	<rect public="1" get="inline" set="null" line="8" static="1">
		<x path="dl.physic.body.ShapeType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</rect>
	<circle public="1" get="inline" set="null" line="9" static="1">
		<x path="dl.physic.body.ShapeType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</circle>
	<_new get="inline" set="null" line="11" static="1">
		<f a="i">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<fromInt public="1" set="method" line="14" static="1">
		<f a="i">
			<x path="Int"/>
			<x path="dl.physic.body.ShapeType"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromInt>
	<toInt public="1" set="method" line="19" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toInt>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="dl.physic.body._Shape.ShapeType_Impl_" params="" file="src/dl/physic/body/Shape.hx" private="1" module="dl.physic.body.Shape">
		<point public="1" get="inline" set="null" line="7" static="1">
			<x path="dl.physic.body.ShapeType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</point>
		<rect public="1" get="inline" set="null" line="8" static="1">
			<x path="dl.physic.body.ShapeType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</rect>
		<circle public="1" get="inline" set="null" line="9" static="1">
			<x path="dl.physic.body.ShapeType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</circle>
		<_new get="inline" set="null" line="11" static="1">
			<f a="i">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<fromInt public="1" set="method" line="14" static="1">
			<f a="i">
				<x path="Int"/>
				<x path="dl.physic.body.ShapeType"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromInt>
		<toInt public="1" set="method" line="19" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toInt>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="dl.physic.body.Shape" params="" file="src/dl/physic/body/Shape.hx">
		<_getHitArea get="inline" set="null" line="60" static="1"><f a="a:b">
	<c path="dl.physic.body.Shape"/>
	<c path="dl.physic.body.Shape"/>
	<x path="Float"/>
</f></_getHitArea>
		<_max get="inline" set="null" line="65" static="1"><f a="a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></_max>
		<_min get="inline" set="null" line="69" static="1"><f a="a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></_min>
		<_getW set="method" line="82" static="1"><f a="a">
	<c path="dl.physic.body.Shape"/>
	<x path="Float"/>
</f></_getW>
		<_getH set="method" line="93" static="1"><f a="a">
	<c path="dl.physic.body.Shape"/>
	<x path="Float"/>
</f></_getH>
		<_hitTest set="method" line="108" static="1"><f a="a:b">
	<c path="dl.physic.body.Shape"/>
	<c path="dl.physic.body.Shape"/>
	<x path="Bool"/>
</f></_hitTest>
		<hitTestAABB get="inline" set="null" line="129" static="1"><f a="a:b">
	<c path="dl.physic.body.Shape"/>
	<c path="dl.physic.body.Shape"/>
	<x path="Bool"/>
</f></hitTestAABB>
		<hitTestCircles set="method" line="137" static="1"><f a="a:b">
	<c path="dl.physic.body.ShapeCircle"/>
	<c path="dl.physic.body.ShapeCircle"/>
	<x path="Bool"/>
</f></hitTestCircles>
		<hitTestPointCircle set="method" line="146" static="1"><f a="a:b">
	<c path="dl.physic.body.ShapePoint"/>
	<c path="dl.physic.body.ShapeCircle"/>
	<x path="Bool"/>
</f></hitTestPointCircle>
		<aabbXMin public="1" set="null"><x path="Float"/></aabbXMin>
		<aabbXMax public="1" set="null"><x path="Float"/></aabbXMax>
		<aabbYMin public="1" set="null"><x path="Float"/></aabbYMin>
		<aabbYMax public="1" set="null"><x path="Float"/></aabbYMax>
		<type public="1" set="null"><x path="dl.physic.body.ShapeType"/></type>
		<clone public="1" set="method" line="40"><f a=""><c path="dl.physic.body.Shape"/></f></clone>
		<updateAABB public="1" set="method" line="51"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></updateAABB>
		<getHitArea public="1" get="inline" set="null" line="56"><f a="s">
	<c path="dl.physic.body.Shape"/>
	<x path="Float"/>
</f></getHitArea>
		<getH public="1" get="inline" set="null" line="74"><f a=""><x path="Float"/></f></getH>
		<getW public="1" get="inline" set="null" line="78"><f a=""><x path="Float"/></f></getW>
		<hitTest public="1" get="inline" set="null" line="104"><f a="b">
	<c path="dl.physic.body.Shape"/>
	<x path="Bool"/>
</f></hitTest>
		<new public="1" set="method" line="38"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Form of the body.
 * 
 * @author Namide</haxe_doc>
	</class>
	<class path="dl.physic.body.ShapeCircle" params="" file="src/dl/physic/body/ShapeCircle.hx">
		<extends path="dl.physic.body.Shape"/>
		<r public="1"><x path="Float"/></r>
		<updateAABB public="1" set="method" line="20" override="1"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></updateAABB>
		<clone public="1" set="method" line="29" override="1"><f a=""><c path="dl.physic.body.ShapeCircle"/></f></clone>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Namide</haxe_doc>
	</class>
	<class path="dl.physic.body.ShapePoint" params="" file="src/dl/physic/body/ShapePoint.hx">
		<extends path="dl.physic.body.Shape"/>
		<clone public="1" set="method" line="17" override="1"><f a=""><c path="dl.physic.body.ShapePoint"/></f></clone>
		<updateAABB public="1" set="method" line="27" override="1"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></updateAABB>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Namide</haxe_doc>
	</class>
	<class path="dl.physic.body.ShapeRect" params="" file="src/dl/physic/body/ShapeRect.hx">
		<extends path="dl.physic.body.Shape"/>
		<w public="1"><x path="Float"/></w>
		<h public="1"><x path="Float"/></h>
		<clone public="1" set="method" line="22" override="1"><f a=""><c path="dl.physic.body.ShapeRect"/></f></clone>
		<updateAABB public="1" set="method" line="33" override="1"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></updateAABB>
		<new public="1" set="method" line="13"><f a="w:h">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Namide</haxe_doc>
	</class>
	<abstract path="dl.physic.contact.BodyLimitFlags" params="" file="src/dl/physic/contact/BodyContact.hx" module="dl.physic.contact.BodyContact">
		<from><icast field="fromInt"><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast field="toInt"><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="dl.physic.contact._BodyContact.BodyLimitFlags_Impl_" params="" file="src/dl/physic/contact/BodyContact.hx" private="1" module="dl.physic.contact.BodyContact">
	<none public="1" get="inline" set="null" line="8" static="1">
		<x path="dl.physic.contact.BodyLimitFlags"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</none>
	<top public="1" get="inline" set="null" line="9" static="1">
		<x path="dl.physic.contact.BodyLimitFlags"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</top>
	<left public="1" get="inline" set="null" line="10" static="1">
		<x path="dl.physic.contact.BodyLimitFlags"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</left>
	<right public="1" get="inline" set="null" line="11" static="1">
		<x path="dl.physic.contact.BodyLimitFlags"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</right>
	<bottom public="1" get="inline" set="null" line="12" static="1">
		<x path="dl.physic.contact.BodyLimitFlags"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</bottom>
	<_new get="inline" set="null" line="14" static="1">
		<f a="i">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<fromInt public="1" set="method" line="17" static="1">
		<f a="i">
			<x path="Int"/>
			<x path="dl.physic.contact.BodyLimitFlags"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromInt>
	<toInt public="1" set="method" line="22" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toInt>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="dl.physic.contact._BodyContact.BodyLimitFlags_Impl_" params="" file="src/dl/physic/contact/BodyContact.hx" private="1" module="dl.physic.contact.BodyContact">
		<none public="1" get="inline" set="null" line="8" static="1">
			<x path="dl.physic.contact.BodyLimitFlags"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</none>
		<top public="1" get="inline" set="null" line="9" static="1">
			<x path="dl.physic.contact.BodyLimitFlags"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</top>
		<left public="1" get="inline" set="null" line="10" static="1">
			<x path="dl.physic.contact.BodyLimitFlags"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</left>
		<right public="1" get="inline" set="null" line="11" static="1">
			<x path="dl.physic.contact.BodyLimitFlags"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</right>
		<bottom public="1" get="inline" set="null" line="12" static="1">
			<x path="dl.physic.contact.BodyLimitFlags"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</bottom>
		<_new get="inline" set="null" line="14" static="1">
			<f a="i">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<fromInt public="1" set="method" line="17" static="1">
			<f a="i">
				<x path="Int"/>
				<x path="dl.physic.contact.BodyLimitFlags"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromInt>
		<toInt public="1" set="method" line="22" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toInt>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="dl.physic.contact.BodyContactState" params="" file="src/dl/physic/contact/BodyContact.hx" module="dl.physic.contact.BodyContact">
		<from><icast field="fromInt"><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast field="toInt"><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="dl.physic.contact._BodyContact.BodyContactState_Impl_" params="" file="src/dl/physic/contact/BodyContact.hx" private="1" module="dl.physic.contact.BodyContact">
	<init public="1" get="inline" set="null" line="30" static="1">
		<x path="dl.physic.contact.BodyContactState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</init>
	<contacts public="1" get="inline" set="null" line="31" static="1">
		<x path="dl.physic.contact.BodyContactState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</contacts>
	<limits public="1" get="inline" set="null" line="32" static="1">
		<x path="dl.physic.contact.BodyContactState"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</limits>
	<_new get="inline" set="null" line="34" static="1">
		<f a="i">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<fromInt public="1" set="method" line="37" static="1">
		<f a="i">
			<x path="Int"/>
			<x path="dl.physic.contact.BodyContactState"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromInt>
	<toInt public="1" set="method" line="42" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toInt>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="dl.physic.contact._BodyContact.BodyContactState_Impl_" params="" file="src/dl/physic/contact/BodyContact.hx" private="1" module="dl.physic.contact.BodyContact">
		<init public="1" get="inline" set="null" line="30" static="1">
			<x path="dl.physic.contact.BodyContactState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</init>
		<contacts public="1" get="inline" set="null" line="31" static="1">
			<x path="dl.physic.contact.BodyContactState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</contacts>
		<limits public="1" get="inline" set="null" line="32" static="1">
			<x path="dl.physic.contact.BodyContactState"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</limits>
		<_new get="inline" set="null" line="34" static="1">
			<f a="i">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<fromInt public="1" set="method" line="37" static="1">
			<f a="i">
				<x path="Int"/>
				<x path="dl.physic.contact.BodyContactState"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromInt>
		<toInt public="1" set="method" line="42" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toInt>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="dl.physic.contact.BodyContactsFlags" params="" file="src/dl/physic/contact/BodyContact.hx" module="dl.physic.contact.BodyContact">
		<from><icast field="fromInt"><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast field="toInt"><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="dl.physic.contact._BodyContact.BodyContactsFlags_Impl_" params="" file="src/dl/physic/contact/BodyContact.hx" private="1" module="dl.physic.contact.BodyContact">
	<passive public="1" get="inline" set="null" line="53" static="1">
		<x path="dl.physic.contact.BodyContactsFlags"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* This body don't test the collision but the actives bodies tests the collision with this one</haxe_doc>
	</passive>
	<active public="1" get="inline" set="null" line="58" static="1">
		<x path="dl.physic.contact.BodyContactsFlags"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* This body test the collision with the passives bodies</haxe_doc>
	</active>
	<platformBottom public="1" get="inline" set="null" line="63" static="1">
		<x path="dl.physic.contact.BodyContactsFlags"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* You can jump from bottom over a platform</haxe_doc>
	</platformBottom>
	<platformTop public="1" get="inline" set="null" line="64" static="1">
		<x path="dl.physic.contact.BodyContactsFlags"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</platformTop>
	<platformLeft public="1" get="inline" set="null" line="65" static="1">
		<x path="dl.physic.contact.BodyContactsFlags"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</platformLeft>
	<platformRight public="1" get="inline" set="null" line="66" static="1">
		<x path="dl.physic.contact.BodyContactsFlags"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</platformRight>
	<wall public="1" get="inline" set="null" line="71" static="1">
		<x path="dl.physic.contact.BodyContactsFlags"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* You can't cross it</haxe_doc>
	</wall>
	<item public="1" get="inline" set="null" line="82" static="1">
		<x path="dl.physic.contact.BodyContactsFlags"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* You can climb it</haxe_doc>
	</item>
	<fix public="1" get="inline" set="null" line="87" static="1">
		<x path="dl.physic.contact.BodyContactsFlags"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* Never move (like wall or floor)</haxe_doc>
	</fix>
	<drivable public="1" get="inline" set="null" line="93" static="1">
		<x path="dl.physic.contact.BodyContactsFlags"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* Can be receive data moves out the physic engine.
	 * In example it can be push by an active object.</haxe_doc>
	</drivable>
	<_new get="inline" set="null" line="96" static="1">
		<f a="i">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<fromInt public="1" set="method" line="99" static="1">
		<f a="i">
			<x path="Int"/>
			<x path="dl.physic.contact.BodyContactsFlags"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromInt>
	<toInt public="1" set="method" line="104" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toInt>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="dl.physic.contact._BodyContact.BodyContactsFlags_Impl_" params="" file="src/dl/physic/contact/BodyContact.hx" private="1" module="dl.physic.contact.BodyContact">
		<passive public="1" get="inline" set="null" line="53" static="1">
			<x path="dl.physic.contact.BodyContactsFlags"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* This body don't test the collision but the actives bodies tests the collision with this one</haxe_doc>
		</passive>
		<active public="1" get="inline" set="null" line="58" static="1">
			<x path="dl.physic.contact.BodyContactsFlags"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* This body test the collision with the passives bodies</haxe_doc>
		</active>
		<platformBottom public="1" get="inline" set="null" line="63" static="1">
			<x path="dl.physic.contact.BodyContactsFlags"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* You can jump from bottom over a platform</haxe_doc>
		</platformBottom>
		<platformTop public="1" get="inline" set="null" line="64" static="1">
			<x path="dl.physic.contact.BodyContactsFlags"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</platformTop>
		<platformLeft public="1" get="inline" set="null" line="65" static="1">
			<x path="dl.physic.contact.BodyContactsFlags"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</platformLeft>
		<platformRight public="1" get="inline" set="null" line="66" static="1">
			<x path="dl.physic.contact.BodyContactsFlags"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</platformRight>
		<wall public="1" get="inline" set="null" line="71" static="1">
			<x path="dl.physic.contact.BodyContactsFlags"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* You can't cross it</haxe_doc>
		</wall>
		<item public="1" get="inline" set="null" line="82" static="1">
			<x path="dl.physic.contact.BodyContactsFlags"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* You can climb it</haxe_doc>
		</item>
		<fix public="1" get="inline" set="null" line="87" static="1">
			<x path="dl.physic.contact.BodyContactsFlags"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* Never move (like wall or floor)</haxe_doc>
		</fix>
		<drivable public="1" get="inline" set="null" line="93" static="1">
			<x path="dl.physic.contact.BodyContactsFlags"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* Can be receive data moves out the physic engine.
	 * In example it can be push by an active object.</haxe_doc>
		</drivable>
		<_new get="inline" set="null" line="96" static="1">
			<f a="i">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<fromInt public="1" set="method" line="99" static="1">
			<f a="i">
				<x path="Int"/>
				<x path="dl.physic.contact.BodyContactsFlags"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromInt>
		<toInt public="1" set="method" line="104" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toInt>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="dl.physic.contact.BodyContact" params="" file="src/dl/physic/contact/BodyContact.hx">
		<classBodiesByContactArea public="1" get="inline" set="null" line="143" static="1"><f a="shape:list">
	<c path="dl.physic.body.Shape"/>
	<c path="Array"><c path="dl.physic.body.Body"/></c>
	<x path="Void"/>
</f></classBodiesByContactArea>
		<parent public="1"><c path="dl.physic.body.Body"/></parent>
		<list public="1"><c path="Array"><c path="dl.physic.body.Body"/></c></list>
		<state public="1"><x path="dl.physic.contact.BodyContactState"/></state>
		<flags public="1"><x path="dl.physic.contact.BodyContactsFlags"/></flags>
		<fixedLimits public="1"><x path="dl.physic.contact.BodyLimitFlags"/></fixedLimits>
		<push public="1" get="inline" set="null" line="130"><f a="body">
	<c path="dl.physic.body.Body"/>
	<x path="Void"/>
</f></push>
		<change public="1" get="inline" set="null" line="131"><f a="bodies">
	<c path="Array"><c path="dl.physic.body.Body"/></c>
	<x path="Void"/>
</f></change>
		<length public="1" get="inline" set="null" line="132"><f a=""><x path="Int"/></f></length>
		<classByArea public="1" get="inline" set="null" line="134"><f a=""><x path="Void"/></f></classByArea>
		<clear public="1" get="inline" set="null" line="152"><f a=""><x path="Void"/></f></clear>
		<new public="1" set="method" line="122"><f a="p">
	<c path="dl.physic.body.Body"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Namide</haxe_doc>
	</class>
	<class path="dl.physic.contact.ISpace" params="" file="src/dl/physic/contact/ISpace.hx" interface="1">
		<addBody public="1" set="method"><f a="body">
	<c path="dl.physic.body.Body"/>
	<x path="Void"/>
</f></addBody>
		<removeBody public="1" set="method"><f a="body">
	<c path="dl.physic.body.Body"/>
	<x path="Void"/>
</f></removeBody>
		<hitTest public="1" set="method"><f a=""><c path="List"><c path="dl.physic.body.Body"/></c></f></hitTest>
		<hitTestActive public="1" set="method"><f a="body">
	<c path="dl.physic.body.Body"/>
	<c path="Array"><c path="dl.physic.body.Body"/></c>
</f></hitTestActive>
		<haxe_doc>* @author Namide</haxe_doc>
	</class>
	<class path="dl.physic.contact.Grid" params="" file="src/dl/physic/contact/SpaceGrid.hx" module="dl.physic.contact.SpaceGrid">
		<minTileX public="1" set="null"><x path="Int"/></minTileX>
		<minTileY public="1" set="null"><x path="Int"/></minTileY>
		<maxTileX public="1" set="null"><x path="Int"/></maxTileX>
		<maxTileY public="1" set="null"><x path="Int"/></maxTileY>
		<_grid><c path="Array"><c path="Array"><c path="Array"><c path="dl.physic.contact.Node"/></c></c></c></_grid>
		<outdated public="1"><x path="Bool"/></outdated>
		<remove public="1" get="inline" set="null" line="40"><f a="i:j:node">
	<x path="Int"/>
	<x path="Int"/>
	<c path="dl.physic.contact.Node"/>
	<x path="Void"/>
</f></remove>
		<push public="1" get="inline" set="null" line="49"><f a="i:j:node">
	<x path="Int"/>
	<x path="Int"/>
	<c path="dl.physic.contact.Node"/>
	<x path="Void"/>
</f></push>
		<getNodes public="1" get="inline" set="null" line="58"><f a="i:j">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><c path="dl.physic.contact.Node"/></c>
</f></getNodes>
		<getContacts public="1" get="inline" set="null" line="63"><f a="n">
	<c path="dl.physic.contact.Node"/>
	<c path="Array"><c path="dl.physic.body.Body"/></c>
</f></getContacts>
		<dispose public="1" get="inline" set="null" line="77"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="20"><f a="minTileX:minTileY:maxTileX:maxTileY">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="dl.physic.contact.Node" params="" file="src/dl/physic/contact/SpaceGrid.hx" module="dl.physic.contact.SpaceGrid">
		<body public="1" set="null"><c path="dl.physic.body.Body"/></body>
		<minTileX public="1"><x path="Int"/></minTileX>
		<minTileY public="1"><x path="Int"/></minTileY>
		<maxTileX public="1"><x path="Int"/></maxTileX>
		<maxTileY public="1"><x path="Int"/></maxTileY>
		<inGrid public="1"><x path="Bool"/></inGrid>
		<init public="1" set="method" line="127"><f a="pitchExpX:pitchExpY:grid">
	<x path="Int"/>
	<x path="Int"/>
	<c path="dl.physic.contact.Grid"/>
	<x path="Void"/>
</f></init>
		<removeFromGrid public="1" get="inline" set="null" line="137"><f a="grid">
	<c path="dl.physic.contact.Grid"/>
	<x path="Void"/>
</f></removeFromGrid>
		<refresh public="1" set="method" line="145"><f a="pitchExpX:pitchExpY:grid:?updatePrint" v=":::true">
	<x path="Int"/>
	<x path="Int"/>
	<c path="dl.physic.contact.Grid"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></refresh>
		<new public="1" set="method" line="121"><f a="body">
	<c path="dl.physic.body.Body"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="dl.physic.contact.SpaceGrid" params="" file="src/dl/physic/contact/SpaceGrid.hx">
		<implements path="dl.physic.contact.ISpace"/>
		<all public="1" set="null"><c path="Array"><c path="dl.physic.body.Body"/></c></all>
		<_active set="null"><c path="Array"><c path="dl.physic.contact.Node"/></c></_active>
		<_passive set="null"><c path="Array"><c path="dl.physic.contact.Node"/></c></_passive>
		<_passiveFixed set="null"><c path="Array"><c path="dl.physic.contact.Node"/></c></_passiveFixed>
		<_pitchX><x path="Int"/></_pitchX>
		<_pitchY><x path="Int"/></_pitchY>
		<_grid><c path="dl.physic.contact.Grid"/></_grid>
		<_pitchXExp><x path="Int"/></_pitchXExp>
		<_pitchYExp><x path="Int"/></_pitchYExp>
		<autoLimits><x path="Bool"/></autoLimits>
		<xMin><x path="Int"/></xMin>
		<xMax><x path="Int"/></xMax>
		<yMin><x path="Int"/></yMin>
		<yMax><x path="Int"/></yMax>
		<init set="method" line="234"><f a=""><x path="Void"/></f></init>
		<hitTestActive public="1" set="method" line="254"><f a="b">
	<c path="dl.physic.body.Body"/>
	<c path="Array"><c path="dl.physic.body.Body"/></c>
</f></hitTestActive>
		<hitTest public="1" set="method" line="265"><f a=""><c path="List"><c path="dl.physic.body.Body"/></c></f></hitTest>
		<addBody public="1" set="method" line="302">
			<f a="body">
				<c path="dl.physic.body.Body"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Add a body in this system
	 * 
	 * @param	body			Body to add in the system</haxe_doc>
		</addBody>
		<removeBody public="1" set="method" line="356">
			<f a="body">
				<c path="dl.physic.body.Body"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove the body of the system
	 * 
	 * @param	body			Body to add</haxe_doc>
		</removeBody>
		<new public="1" set="method" line="212"><f a="?tileW:?tileH:?xMin:?xMax:?yMin:?yMax" v="64:64:null:null:null:null">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Namide</haxe_doc>
	</class>
	<class path="dl.physic.contact.SpaceSimple" params="" file="src/dl/physic/contact/SpaceSimple.hx">
		<implements path="dl.physic.contact.ISpace"/>
		<all public="1" set="null"><c path="List"><c path="dl.physic.body.Body"/></c></all>
		<_active set="null"><c path="List"><c path="dl.physic.body.Body"/></c></_active>
		<_passive set="null"><c path="List"><c path="dl.physic.body.Body"/></c></_passive>
		<hitTestActive public="1" set="method" line="24"><f a="b">
	<c path="dl.physic.body.Body"/>
	<c path="Array"><c path="dl.physic.body.Body"/></c>
</f></hitTestActive>
		<hitTest public="1" set="method" line="40"><f a=""><c path="List"><c path="dl.physic.body.Body"/></c></f></hitTest>
		<addBody public="1" set="method" line="78">
			<f a="body">
				<c path="dl.physic.body.Body"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Add a body in this system
	 * 
	 * @param	body			Body to add in the system</haxe_doc>
		</addBody>
		<removeBody public="1" set="method" line="102">
			<f a="body">
				<c path="dl.physic.body.Body"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove the body of the system
	 * 
	 * @param	body			Body to add</haxe_doc>
		</removeBody>
		<new public="1" set="method" line="17"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Namide</haxe_doc>
	</class>
	<abstract path="dl.physic.move.BodyPhysicFlags" params="" file="src/dl/physic/move/BodyPhysic.hx" module="dl.physic.move.BodyPhysic">
		<from><icast field="fromInt"><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast field="toInt"><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="dl.physic.move._BodyPhysic.BodyPhysicFlags_Impl_" params="" file="src/dl/physic/move/BodyPhysic.hx" private="1" module="dl.physic.move.BodyPhysic">
	<none public="1" get="inline" set="null" line="10" static="1">
		<x path="dl.physic.move.BodyPhysicFlags"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* Not active physic (like an IA) but an other body can interract with this</haxe_doc>
	</none>
	<dependant public="1" get="inline" set="null" line="15" static="1">
		<x path="dl.physic.move.BodyPhysicFlags"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* Your solid reacts with passives bodies (platform, wall, ladder)</haxe_doc>
	</dependant>
	<velocity public="1" get="inline" set="null" line="20" static="1">
		<x path="dl.physic.move.BodyPhysicFlags"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* Physic engine apply the velocity</haxe_doc>
	</velocity>
	<gravity public="1" get="inline" set="null" line="25" static="1">
		<x path="dl.physic.move.BodyPhysicFlags"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* Physic engine apply the gravity</haxe_doc>
	</gravity>
	<_new get="inline" set="null" line="27" static="1">
		<f a="i">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<fromInt public="1" set="method" line="30" static="1">
		<f a="i">
			<x path="Int"/>
			<x path="dl.physic.move.BodyPhysicFlags"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromInt>
	<toInt public="1" set="method" line="35" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toInt>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="dl.physic.move._BodyPhysic.BodyPhysicFlags_Impl_" params="" file="src/dl/physic/move/BodyPhysic.hx" private="1" module="dl.physic.move.BodyPhysic">
		<none public="1" get="inline" set="null" line="10" static="1">
			<x path="dl.physic.move.BodyPhysicFlags"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* Not active physic (like an IA) but an other body can interract with this</haxe_doc>
		</none>
		<dependant public="1" get="inline" set="null" line="15" static="1">
			<x path="dl.physic.move.BodyPhysicFlags"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* Your solid reacts with passives bodies (platform, wall, ladder)</haxe_doc>
		</dependant>
		<velocity public="1" get="inline" set="null" line="20" static="1">
			<x path="dl.physic.move.BodyPhysicFlags"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* Physic engine apply the velocity</haxe_doc>
		</velocity>
		<gravity public="1" get="inline" set="null" line="25" static="1">
			<x path="dl.physic.move.BodyPhysicFlags"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* Physic engine apply the gravity</haxe_doc>
		</gravity>
		<_new get="inline" set="null" line="27" static="1">
			<f a="i">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<fromInt public="1" set="method" line="30" static="1">
			<f a="i">
				<x path="Int"/>
				<x path="dl.physic.move.BodyPhysicFlags"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromInt>
		<toInt public="1" set="method" line="35" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toInt>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="dl.physic.move.BodyPhysic" params="" file="src/dl/physic/move/BodyPhysic.hx">
		<_parent><c path="dl.physic.body.Body"/></_parent>
		<vX public="1"><x path="Float"/></vX>
		<vY public="1"><x path="Float"/></vY>
		<flags public="1"><x path="dl.physic.move.BodyPhysicFlags"/></flags>
		<mass public="1"><x path="Float"/></mass>
		<new public="1" set="method" line="54"><f a="parent">
	<c path="dl.physic.body.Body"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Namide</haxe_doc>
	</class>
	<class path="dl.physic.move.PlatformPhysicSystem" params="" file="src/dl/physic/move/PlatformPhysicSystem.hx">
		<MAX_RECURSIVE get="inline" set="null" line="21" static="1">
			<x path="Int"/>
			<haxe_doc>* To prevent error collision.
	 * More recursive is better for accuracy but less to memory and performances</haxe_doc>
		</MAX_RECURSIVE>
		<all><c path="Array"><c path="dl.physic.body.Body"/></c></all>
		<gX public="1"><x path="Float"/></gX>
		<gY public="1"><x path="Float"/></gY>
		<addBody public="1" set="method" line="32"><f a="body">
	<c path="dl.physic.body.Body"/>
	<x path="Void"/>
</f></addBody>
		<updateMoves public="1" set="method" line="41"><f a=""><x path="Void"/></f></updateMoves>
		<updatePositions public="1" set="method" line="60"><f a="space">
	<c path="dl.physic.contact.ISpace"/>
	<x path="Void"/>
</f></updatePositions>
		<filterDrivable get="inline" set="null" line="75"><f a="list">
	<c path="Array"><c path="dl.physic.body.Body"/></c>
	<c path="Array"><c path="dl.physic.body.Body"/></c>
</f></filterDrivable>
		<filterUndrivable get="inline" set="null" line="80"><f a="list">
	<c path="Array"><c path="dl.physic.body.Body"/></c>
	<c path="Array"><c path="dl.physic.body.Body"/></c>
</f></filterUndrivable>
		<getPos get="inline" set="null" line="85"><f a="a:b">
	<c path="dl.physic.body.Body"/>
	<c path="dl.physic.body.Body"/>
	<x path="dl.physic.contact.BodyLimitFlags"/>
</f></getPos>
		<applyVertMobilesReact set="method" line="174"><f a="top:bottom">
	<c path="dl.physic.body.Body"/>
	<c path="dl.physic.body.Body"/>
	<x path="Bool"/>
</f></applyVertMobilesReact>
		<applyHorMobilesReact set="method" line="206"><f a="left:right">
	<c path="dl.physic.body.Body"/>
	<c path="dl.physic.body.Body"/>
	<x path="Bool"/>
</f></applyHorMobilesReact>
		<applyReact set="method" line="238"><f a="a:b:reactBody">
	<c path="dl.physic.body.Body"/>
	<c path="dl.physic.body.Body"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></applyReact>
		<updatePosBody set="method" line="329"><f a="a:list:space:?complexCol:?num" v=":::false:0">
	<c path="dl.physic.body.Body"/>
	<c path="Array"><c path="dl.physic.body.Body"/></c>
	<c path="dl.physic.contact.ISpace"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></updatePosBody>
		<removeBody public="1" get="inline" set="null" line="352"><f a="body">
	<c path="dl.physic.body.Body"/>
	<x path="Void"/>
</f></removeBody>
		<new public="1" set="method" line="26"><f a="?gravityY" v="2.0f">
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Namide</haxe_doc>
	</class>
	<class path="dl.physic.move.PlatformUtils" params="" file="src/dl/physic/move/PlatformUtils.hx">
		<getVX public="1" get="inline" set="null" line="14" static="1"><f a="pxBySec:frameDelay">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></getVX>
		<getJumpStartVY public="1" get="inline" set="null" line="18" static="1"><f a="jumpPx:gravity">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></getJumpStartVY>
		<getJumpVY public="1" get="inline" set="null" line="22" static="1"><f a="maxPxJump:jumpStartVY:gravity">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></getJumpVY>
		<getJumpVX public="1" get="inline" set="null" line="26" static="1"><f a="maxPxJump:jumpStartVY:?jumpVY:gravity" v="::0:">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></getJumpVX>
		<maxPxYJump public="1" set="method" line="30" static="1"><f a="maxPxXJump:jumpStartVY:jumpVX:jumpVY:gravity">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></maxPxYJump>
		<maxPxXJump public="1" set="method" line="50" static="1"><f a="maxPxYJump:jumpStartVY:jumpVX:jumpVY:gravity">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></maxPxXJump>
		<new get="inline" set="null" line="10"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Namide</haxe_doc>
	</class>
	<class path="dl.render.RenderHeaps" params="" file="src/dl/render/RenderHeaps.hx">
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Namide</haxe_doc>
	</class>
	<class path="dl.socket.SockConfig" params="" file="src/dl/socket/SockConfig.hx">
		<IP public="1" line="10" static="1"><c path="String"/></IP>
		<PORT public="1" line="11" static="1"><x path="UInt"/></PORT>
		<USER_NAME_LENGTH_MIN public="1" line="13" static="1"><x path="UInt"/></USER_NAME_LENGTH_MIN>
		<USER_NAME_LENGTH_MAX public="1" line="14" static="1"><x path="UInt"/></USER_NAME_LENGTH_MAX>
		<ROOM_NAME_LENGTH_MIN public="1" line="16" static="1"><x path="UInt"/></ROOM_NAME_LENGTH_MIN>
		<ROOM_NAME_LENGTH_MAX public="1" line="17" static="1"><x path="UInt"/></ROOM_NAME_LENGTH_MAX>
		<MSG_LENGTH_MIN public="1" line="19" static="1"><x path="UInt"/></MSG_LENGTH_MIN>
		<MSG_LENGTH_MAX public="1" line="20" static="1"><x path="UInt"/></MSG_LENGTH_MAX>
		<ROOM_DEFAULT_NAME public="1" line="22" static="1"><c path="String"/></ROOM_DEFAULT_NAME>
		<ROOM_DEFAULT_IS_LOBBY public="1" line="23" static="1"><x path="Bool"/></ROOM_DEFAULT_IS_LOBBY>
		<ROOM_LIST_WITH_DATAS public="1" line="24" static="1"><x path="Bool"/></ROOM_LIST_WITH_DATAS>
		<ROOM_COOKIE public="1" line="26" static="1"><x path="Bool"/></ROOM_COOKIE>
		<USER_NAME_GEN public="1" set="dynamic" line="27" static="1"><f a="seed">
	<x path="Int"/>
	<c path="String"/>
</f></USER_NAME_GEN>
		<SERVER_USERS_FILE public="1" line="36" static="1">
			<t path="Null"><c path="String"/></t>
			<haxe_doc>* Null to disable user registered</haxe_doc>
		</SERVER_USERS_FILE>
		<SERVER_LOGS public="1" line="37" static="1"><x path="Bool"/></SERVER_LOGS>
		<SEND_POLICY_843 public="1" line="43" static="1">
			<x path="Bool"/>
			<haxe_doc>* Port 843 only for admin.
	 * Required for Flash 10+</haxe_doc>
		</SEND_POLICY_843>
		<haxe_doc>* ...
 * @author Namide</haxe_doc>
	</class>
	<abstract path="dl.socket.Cmd" params="" file="src/dl/socket/SockMsg.hx" module="dl.socket.SockMsg">
		<from>
			<icast field="fromInt"><x path="Int"/></icast>
			<icast field="fromString"><c path="String"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to><icast field="toInt"><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="dl.socket._SockMsg.Cmd_Impl_" params="" file="src/dl/socket/SockMsg.hx" private="1" module="dl.socket.SockMsg">
	<other public="1" get="inline" set="null" line="6" static="1">
		<x path="dl.socket.Cmd"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</other>
	<transferDatasClient public="1" get="inline" set="null" line="7" static="1">
		<x path="dl.socket.Cmd"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</transferDatasClient>
	<transferDatasServer public="1" get="inline" set="null" line="8" static="1">
		<x path="dl.socket.Cmd"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</transferDatasServer>
	<send public="1" get="inline" set="null" line="9" static="1">
		<x path="dl.socket.Cmd"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</send>
	<_new get="inline" set="null" line="11" static="1">
		<f a="i">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<fromInt public="1" set="method" line="14" static="1">
		<f a="i">
			<x path="Int"/>
			<x path="dl.socket.Cmd"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromInt>
	<fromString public="1" set="method" line="19" static="1">
		<f a="s">
			<c path="String"/>
			<x path="dl.socket.Cmd"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toInt public="1" set="method" line="24" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toInt>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="dl.socket._SockMsg.Cmd_Impl_" params="" file="src/dl/socket/SockMsg.hx" private="1" module="dl.socket.SockMsg">
		<other public="1" get="inline" set="null" line="6" static="1">
			<x path="dl.socket.Cmd"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</other>
		<transferDatasClient public="1" get="inline" set="null" line="7" static="1">
			<x path="dl.socket.Cmd"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</transferDatasClient>
		<transferDatasServer public="1" get="inline" set="null" line="8" static="1">
			<x path="dl.socket.Cmd"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</transferDatasServer>
		<send public="1" get="inline" set="null" line="9" static="1">
			<x path="dl.socket.Cmd"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</send>
		<_new get="inline" set="null" line="11" static="1">
			<f a="i">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<fromInt public="1" set="method" line="14" static="1">
			<f a="i">
				<x path="Int"/>
				<x path="dl.socket.Cmd"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromInt>
		<fromString public="1" set="method" line="19" static="1">
			<f a="s">
				<c path="String"/>
				<x path="dl.socket.Cmd"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toInt public="1" set="method" line="24" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toInt>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="dl.socket.SendSubject" params="" file="src/dl/socket/SockMsg.hx" module="dl.socket.SockMsg">
		<from><icast field="fromInt"><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast field="toInt"><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="dl.socket._SockMsg.SendSubject_Impl_" params="" file="src/dl/socket/SockMsg.hx" private="1" module="dl.socket.SockMsg">
	<roomList public="1" get="inline" set="null" line="32" static="1">
		<x path="dl.socket.SendSubject"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</roomList>
	<errorSystem public="1" get="inline" set="null" line="33" static="1">
		<x path="dl.socket.SendSubject"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</errorSystem>
	<messageSystem public="1" get="inline" set="null" line="34" static="1">
		<x path="dl.socket.SendSubject"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</messageSystem>
	<connect public="1" get="inline" set="null" line="35" static="1">
		<x path="dl.socket.SendSubject"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</connect>
	<chat public="1" get="inline" set="null" line="36" static="1">
		<x path="dl.socket.SendSubject"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</chat>
	<register public="1" get="inline" set="null" line="37" static="1">
		<x path="dl.socket.SendSubject"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</register>
	<login public="1" get="inline" set="null" line="38" static="1">
		<x path="dl.socket.SendSubject"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</login>
	<kick public="1" get="inline" set="null" line="39" static="1">
		<x path="dl.socket.SendSubject"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</kick>
	<user public="1" get="inline" set="null" line="40" static="1">
		<x path="dl.socket.SendSubject"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</user>
	<room public="1" get="inline" set="null" line="41" static="1">
		<x path="dl.socket.SendSubject"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</room>
	<_new get="inline" set="null" line="43" static="1">
		<f a="s">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<fromInt public="1" set="method" line="46" static="1">
		<f a="i">
			<x path="Int"/>
			<x path="dl.socket.SendSubject"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromInt>
	<toInt public="1" set="method" line="51" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toInt>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="dl.socket._SockMsg.SendSubject_Impl_" params="" file="src/dl/socket/SockMsg.hx" private="1" module="dl.socket.SockMsg">
		<roomList public="1" get="inline" set="null" line="32" static="1">
			<x path="dl.socket.SendSubject"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</roomList>
		<errorSystem public="1" get="inline" set="null" line="33" static="1">
			<x path="dl.socket.SendSubject"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</errorSystem>
		<messageSystem public="1" get="inline" set="null" line="34" static="1">
			<x path="dl.socket.SendSubject"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</messageSystem>
		<connect public="1" get="inline" set="null" line="35" static="1">
			<x path="dl.socket.SendSubject"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</connect>
		<chat public="1" get="inline" set="null" line="36" static="1">
			<x path="dl.socket.SendSubject"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</chat>
		<register public="1" get="inline" set="null" line="37" static="1">
			<x path="dl.socket.SendSubject"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</register>
		<login public="1" get="inline" set="null" line="38" static="1">
			<x path="dl.socket.SendSubject"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</login>
		<kick public="1" get="inline" set="null" line="39" static="1">
			<x path="dl.socket.SendSubject"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</kick>
		<user public="1" get="inline" set="null" line="40" static="1">
			<x path="dl.socket.SendSubject"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</user>
		<room public="1" get="inline" set="null" line="41" static="1">
			<x path="dl.socket.SendSubject"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</room>
		<_new get="inline" set="null" line="43" static="1">
			<f a="s">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<fromInt public="1" set="method" line="46" static="1">
			<f a="i">
				<x path="Int"/>
				<x path="dl.socket.SendSubject"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromInt>
		<toInt public="1" set="method" line="51" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toInt>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="dl.socket.Role" params="" file="src/dl/socket/SockMsg.hx" module="dl.socket.SockMsg">
		<from><icast field="fromInt"><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast field="toInt"><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="dl.socket._SockMsg.Role_Impl_" params="" file="src/dl/socket/SockMsg.hx" private="1" module="dl.socket.SockMsg">
	<basic public="1" get="inline" set="null" line="59" static="1">
		<x path="dl.socket.Role"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</basic>
	<roomMaster public="1" get="inline" set="null" line="60" static="1">
		<x path="dl.socket.Role"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</roomMaster>
	<admin public="1" get="inline" set="null" line="61" static="1">
		<x path="dl.socket.Role"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</admin>
	<_new get="inline" set="null" line="63" static="1">
		<f a="s">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<fromInt public="1" set="method" line="66" static="1">
		<f a="i">
			<x path="Int"/>
			<x path="dl.socket.Role"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromInt>
	<toInt public="1" set="method" line="71" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toInt>
	<sup public="1" set="method" line="76" static="1">
		<f a="this:r">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e><![CDATA[A>B]]></e></m>
		</meta>
	</sup>
	<inf public="1" set="method" line="82" static="1">
		<f a="this:r">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":op"><e><![CDATA[A<B]]></e></m>
		</meta>
	</inf>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="dl.socket._SockMsg.Role_Impl_" params="" file="src/dl/socket/SockMsg.hx" private="1" module="dl.socket.SockMsg">
		<basic public="1" get="inline" set="null" line="59" static="1">
			<x path="dl.socket.Role"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</basic>
		<roomMaster public="1" get="inline" set="null" line="60" static="1">
			<x path="dl.socket.Role"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</roomMaster>
		<admin public="1" get="inline" set="null" line="61" static="1">
			<x path="dl.socket.Role"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</admin>
		<_new get="inline" set="null" line="63" static="1">
			<f a="s">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<fromInt public="1" set="method" line="66" static="1">
			<f a="i">
				<x path="Int"/>
				<x path="dl.socket.Role"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromInt>
		<toInt public="1" set="method" line="71" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toInt>
		<sup public="1" set="method" line="76" static="1">
			<f a="this:r">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e><![CDATA[A>B]]></e></m>
			</meta>
		</sup>
		<inf public="1" set="method" line="82" static="1">
			<f a="this:r">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":op"><e><![CDATA[A<B]]></e></m>
			</meta>
		</inf>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="dl.socket.SockMsgGen" params="" file="src/dl/socket/SockMsg.hx" module="dl.socket.SockMsg">
		<getSend public="1" set="method" line="111" static="1"><f a="subject:?content" v=":null">
	<x path="dl.socket.SendSubject"/>
	<d/>
	<c path="dl.socket.SockMsg"/>
</f></getSend>
		<getTransferDatasServer public="1" set="method" line="126" static="1"><f a="data:userId">
	<c path="String"/>
	<x path="Int"/>
	<c path="dl.socket.SockMsg"/>
</f></getTransferDatasServer>
		<getTransferDatasClient public="1" get="inline" set="null" line="132" static="1"><f a="data">
	<d/>
	<c path="dl.socket.SockMsg"/>
</f></getTransferDatasClient>
		<new set="method" line="90"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="dl.socket.SockMsg" params="" file="src/dl/socket/SockMsg.hx">
		<fromString public="1" set="method" line="148" static="1"><f a="text">
	<c path="String"/>
	<c path="dl.socket.SockMsg"/>
</f></fromString>
		<cmd public="1"><x path="dl.socket.Cmd"/></cmd>
		<struct public="1"><d/></struct>
		<getString public="1" set="method" line="190"><f a=""><c path="String"/></f></getString>
		<new public="1" get="inline" set="null" line="142"><f a="?cmd:?struct" v="null:null">
	<x path="dl.socket.Cmd"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="dl.socket.UserData" params="" file="src/dl/socket/SockMsg.hx" module="dl.socket.SockMsg"><a>
	<r>
		<t path="Null"><t path="dl.socket.RoomData"/></t>
		<meta><m n=":optional"/></meta>
	</r>
	<n>
		<c path="String"/>
		<meta><m n=":optional"/></meta>
	</n>
	<m>
		<t path="Null"><x path="dl.socket.Role"/></t>
		<meta><m n=":optional"/></meta>
	</m>
	<i>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</i>
	<d>
		<d/>
		<meta><m n=":optional"/></meta>
	</d>
</a></typedef>
	<typedef path="dl.socket.UserID" params="" file="src/dl/socket/SockMsg.hx" module="dl.socket.SockMsg"><a>
	<p><c path="String"/></p>
	<n><c path="String"/></n>
	<m><c path="String"/></m>
</a></typedef>
	<typedef path="dl.socket.Send" params="" file="src/dl/socket/SockMsg.hx" module="dl.socket.SockMsg"><a>
	<s><x path="dl.socket.SendSubject"/></s>
	<d>
		<d/>
		<meta><m n=":optional"/></meta>
	</d>
</a></typedef>
	<typedef path="dl.socket.Chat" params="" file="src/dl/socket/SockMsg.hx" module="dl.socket.SockMsg"><a>
	<t>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</t>
	<m><c path="String"/></m>
	<f>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</f>
</a></typedef>
	<typedef path="dl.socket.RoomData" params="" file="src/dl/socket/SockMsg.hx" module="dl.socket.SockMsg"><a>
	<u>
		<c path="Array"><t path="dl.socket.UserData"/></c>
		<meta><m n=":optional"/></meta>
	</u>
	<p>
		<c path="String"/>
		<meta><m n=":optional"/></meta>
	</p>
	<n>
		<c path="String"/>
		<meta><m n=":optional"/></meta>
	</n>
	<l>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</l>
	<d>
		<d/>
		<meta><m n=":optional"/></meta>
	</d>
</a></typedef>
	<typedef path="dl.socket.RoomList" params="" file="src/dl/socket/SockMsg.hx" module="dl.socket.SockMsg"><a><r><c path="Array"><t path="dl.socket.RoomData"/></c></r></a></typedef>
	<typedef path="dl.socket.TransferDatasServer" params="" file="src/dl/socket/SockMsg.hx" module="dl.socket.SockMsg"><a>
	<i><x path="Int"/></i>
	<d><c path="String"/></d>
</a></typedef>
	<abstract path="dl.socket.client.SystemMsg" params="" file="src/dl/socket/client/SockClientScan.hx" module="dl.socket.client.SockClientScan">
		<from><icast field="fromInt"><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast field="toInt"><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="dl.socket.client._SockClientScan.SystemMsg_Impl_" params="" file="src/dl/socket/client/SockClientScan.hx" private="1" module="dl.socket.client.SockClientScan">
	<error public="1" get="inline" set="null" line="16" static="1">
		<x path="dl.socket.client.SystemMsg"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</error>
	<message public="1" get="inline" set="null" line="17" static="1">
		<x path="dl.socket.client.SystemMsg"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</message>
	<_new get="inline" set="null" line="19" static="1">
		<f a="s">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<fromInt public="1" set="method" line="22" static="1">
		<f a="i">
			<x path="Int"/>
			<x path="dl.socket.client.SystemMsg"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromInt>
	<toInt public="1" set="method" line="27" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toInt>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="dl.socket.client._SockClientScan.SystemMsg_Impl_" params="" file="src/dl/socket/client/SockClientScan.hx" private="1" module="dl.socket.client.SockClientScan">
		<error public="1" get="inline" set="null" line="16" static="1">
			<x path="dl.socket.client.SystemMsg"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</error>
		<message public="1" get="inline" set="null" line="17" static="1">
			<x path="dl.socket.client.SystemMsg"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</message>
		<_new get="inline" set="null" line="19" static="1">
			<f a="s">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<fromInt public="1" set="method" line="22" static="1">
			<f a="i">
				<x path="Int"/>
				<x path="dl.socket.client.SystemMsg"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromInt>
		<toInt public="1" set="method" line="27" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toInt>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="dl.socket.client.SockClientScan" params="" file="src/dl/socket/client/SockClientScan.hx">
		<me public="1"><c path="dl.socket.client.SockClientUser"/></me>
		<others public="1"><c path="Array"><c path="dl.socket.client.SockClientUser"/></c></others>
		<onMe public="1"><f a="">
	<c path="dl.socket.client.SockClientUser"/>
	<x path="Void"/>
</f></onMe>
		<onOthers public="1"><f a="">
	<c path="Array"><c path="dl.socket.client.SockClientUser"/></c>
	<x path="Void"/>
</f></onOthers>
		<onConnected public="1"><f a="">
	<c path="dl.socket.client.SockClientUser"/>
	<x path="Void"/>
</f></onConnected>
		<onRoomChange public="1"><f a=":">
	<c path="String"/>
	<c path="Array"><c path="dl.socket.client.SockClientUser"/></c>
	<x path="Void"/>
</f></onRoomChange>
		<onRoomData public="1"><f a="">
	<d/>
	<x path="Void"/>
</f></onRoomData>
		<onMsgSystem public="1"><f a=":">
	<c path="String"/>
	<x path="dl.socket.client.SystemMsg"/>
	<x path="Void"/>
</f></onMsgSystem>
		<onRoomList public="1"><f a="">
	<c path="Array"><t path="dl.socket.RoomData"/></c>
	<x path="Void"/>
</f></onRoomList>
		<onChat public="1"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></onChat>
		<onGame public="1"><f a="">
	<t path="dl.socket.TransferDatasServer"/>
	<x path="Void"/>
</f></onGame>
		<_roomName><c path="String"/></_roomName>
		<roomName public="1" get="accessor" set="null"><c path="String"/></roomName>
		<get_roomName set="method" line="54"><f a=""><c path="String"/></f></get_roomName>
		<_roomDatas><d/></_roomDatas>
		<roomDatas public="1" get="accessor" set="null"><d/></roomDatas>
		<get_roomDatas set="method" line="58"><f a=""><d/></f></get_roomDatas>
		<_socket><c path="dl.socket.client.SockPipe"/></_socket>
		<_connected><x path="Bool"/></_connected>
		<_onConnected get="inline" set="null" line="64"><f a="u">
	<c path="dl.socket.client.SockClientUser"/>
	<x path="Void"/>
</f></_onConnected>
		<_onMe get="inline" set="null" line="65"><f a="u">
	<c path="dl.socket.client.SockClientUser"/>
	<x path="Void"/>
</f></_onMe>
		<_onOthers get="inline" set="null" line="66"><f a="a">
	<c path="Array"><c path="dl.socket.client.SockClientUser"/></c>
	<x path="Void"/>
</f></_onOthers>
		<_onRoomChange get="inline" set="null" line="67"><f a="r:a">
	<c path="String"/>
	<c path="Array"><c path="dl.socket.client.SockClientUser"/></c>
	<x path="Void"/>
</f></_onRoomChange>
		<_onRoomData get="inline" set="null" line="68"><f a="d">
	<d/>
	<x path="Void"/>
</f></_onRoomData>
		<_onRoomList get="inline" set="null" line="69"><f a="a">
	<c path="Array"><t path="dl.socket.RoomData"/></c>
	<x path="Void"/>
</f></_onRoomList>
		<_onChat get="inline" set="null" line="70"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></_onChat>
		<_onGame get="inline" set="null" line="71"><f a="t">
	<t path="dl.socket.TransferDatasServer"/>
	<x path="Void"/>
</f></_onGame>
		<_onMsgSystem get="inline" set="null" line="72"><f a="msg:type">
	<c path="String"/>
	<x path="dl.socket.client.SystemMsg"/>
	<x path="Void"/>
</f></_onMsgSystem>
		<connection set="method" line="87"><f a="socket">
	<c path="dl.socket.client.SockPipe"/>
	<x path="Void"/>
</f></connection>
		<close public="1" set="method" line="114"><f a=""><x path="Void"/></f></close>
		<transfertData public="1" get="inline" set="null" line="120"><f a="text">
	<d/>
	<x path="Void"/>
</f></transfertData>
		<appliChat public="1" set="method" line="126"><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></appliChat>
		<getUserById public="1" get="inline" set="null" line="267"><f a="id">
	<x path="Int"/>
	<t path="Null"><c path="dl.socket.client.SockClientUser"/></t>
</f></getUserById>
		<setRoom set="method" line="272"><f a="o">
	<t path="dl.socket.RoomData"/>
	<x path="Void"/>
</f></setRoom>
		<initMe set="method" line="302"><f a="o">
	<t path="dl.socket.UserData"/>
	<x path="Void"/>
</f></initMe>
		<setUser set="method" line="324"><f a="o:?dispatchMsg" v=":true">
	<t path="dl.socket.UserData"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setUser>
		<printChatMsg set="method" line="409"><f a="o">
	<t path="dl.socket.Chat"/>
	<x path="Void"/>
</f></printChatMsg>
		<printRoomList set="method" line="432"><f a="rl">
	<c path="Array"><t path="dl.socket.RoomData"/></c>
	<x path="Void"/>
</f></printRoomList>
		<send public="1" set="method" line="448"><f a="msg">
	<c path="dl.socket.SockMsg"/>
	<x path="Void"/>
</f></send>
		<appliServer public="1" set="method" line="453"><f a="brut">
	<c path="dl.socket.SockMsg"/>
	<x path="Void"/>
</f></appliServer>
		<new public="1" set="method" line="74"><f a="?me" v="null">
	<c path="dl.socket.client.SockClientUser"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Namide</haxe_doc>
	</class>
	<class path="flash.events.IEventDispatcher" params="" file="C:\HaxeToolkit\haxe\std/flash/events/IEventDispatcher.hx" extern="1" interface="1">
		<addEventListener public="1" set="method"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></addEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<x path="Bool"/>
</f></dispatchEvent>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></hasEventListener>
		<removeEventListener public="1" set="method"><f a="type:listener:?useCapture">
	<c path="String"/>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Void"/>
</f></removeEventListener>
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></willTrigger>
	</class>
	<class path="flash.events.EventDispatcher" params="" file="C:\HaxeToolkit\haxe\std/flash/events/EventDispatcher.hx" extern="1">
		<implements path="flash.events.IEventDispatcher"/>
		<addEventListener public="1" set="method"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></addEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<x path="Bool"/>
</f></dispatchEvent>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></hasEventListener>
		<removeEventListener public="1" set="method"><f a="type:listener:?useCapture">
	<c path="String"/>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Void"/>
</f></removeEventListener>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></willTrigger>
		<new public="1" set="method"><f a="?target">
	<c path="flash.events.IEventDispatcher"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.display.IBitmapDrawable" params="" file="C:\HaxeToolkit\haxe\std/flash/display/IBitmapDrawable.hx" extern="1" interface="1"/>
	<class path="flash.display.DisplayObject" params="" file="C:\HaxeToolkit\haxe\std/flash/display/DisplayObject.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<implements path="flash.display.IBitmapDrawable"/>
		<accessibilityProperties public="1"><c path="flash.accessibility.AccessibilityProperties"/></accessibilityProperties>
		<alpha public="1"><x path="Float"/></alpha>
		<blendMode public="1"><e path="flash.display.BlendMode"/></blendMode>
		<blendShader public="1" get="null">
			<c path="flash.display.Shader"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</blendShader>
		<cacheAsBitmap public="1"><x path="Bool"/></cacheAsBitmap>
		<filters public="1"><c path="Array"><c path="flash.filters.BitmapFilter"/></c></filters>
		<height public="1"><x path="Float"/></height>
		<loaderInfo public="1" set="null"><c path="flash.display.LoaderInfo"/></loaderInfo>
		<mask public="1"><c path="flash.display.DisplayObject"/></mask>
		<mouseX public="1" set="null"><x path="Float"/></mouseX>
		<mouseY public="1" set="null"><x path="Float"/></mouseY>
		<name public="1"><c path="String"/></name>
		<opaqueBackground public="1"><t path="Null"><x path="UInt"/></t></opaqueBackground>
		<parent public="1" set="null"><c path="flash.display.DisplayObjectContainer"/></parent>
		<root public="1" set="null"><c path="flash.display.DisplayObject"/></root>
		<rotation public="1"><x path="Float"/></rotation>
		<rotationX public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</rotationX>
		<rotationY public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</rotationY>
		<rotationZ public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</rotationZ>
		<scale9Grid public="1"><c path="flash.geom.Rectangle"/></scale9Grid>
		<scaleX public="1"><x path="Float"/></scaleX>
		<scaleY public="1"><x path="Float"/></scaleY>
		<scaleZ public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</scaleZ>
		<scrollRect public="1"><c path="flash.geom.Rectangle"/></scrollRect>
		<stage public="1" set="null"><c path="flash.display.Stage"/></stage>
		<transform public="1"><c path="flash.geom.Transform"/></transform>
		<visible public="1"><x path="Bool"/></visible>
		<width public="1"><x path="Float"/></width>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</z>
		<getBounds public="1" set="method"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getBounds>
		<getRect public="1" set="method"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getRect>
		<globalToLocal public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></globalToLocal>
		<globalToLocal3D public="1" set="method">
			<f a="point">
				<c path="flash.geom.Point"/>
				<c path="flash.geom.Vector3D"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</globalToLocal3D>
		<hitTestObject public="1" set="method"><f a="obj">
	<c path="flash.display.DisplayObject"/>
	<x path="Bool"/>
</f></hitTestObject>
		<hitTestPoint public="1" set="method"><f a="x:y:?shapeFlag">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></hitTestPoint>
		<local3DToGlobal public="1" set="method">
			<f a="point3d">
				<c path="flash.geom.Vector3D"/>
				<c path="flash.geom.Point"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</local3DToGlobal>
		<localToGlobal public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></localToGlobal>
	</class>
	<class path="flash.display.InteractiveObject" params="" file="C:\HaxeToolkit\haxe\std/flash/display/InteractiveObject.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<accessibilityImplementation public="1"><c path="flash.accessibility.AccessibilityImplementation"/></accessibilityImplementation>
		<contextMenu public="1"><c path="flash.ui.ContextMenu"/></contextMenu>
		<doubleClickEnabled public="1"><x path="Bool"/></doubleClickEnabled>
		<focusRect public="1"><d/></focusRect>
		<mouseEnabled public="1"><x path="Bool"/></mouseEnabled>
		<tabEnabled public="1"><x path="Bool"/></tabEnabled>
		<tabIndex public="1"><x path="Int"/></tabIndex>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.display.DisplayObjectContainer" params="" file="C:\HaxeToolkit\haxe\std/flash/display/DisplayObjectContainer.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<mouseChildren public="1"><x path="Bool"/></mouseChildren>
		<numChildren public="1" set="null"><x path="Int"/></numChildren>
		<tabChildren public="1"><x path="Bool"/></tabChildren>
		<textSnapshot public="1" set="null"><c path="flash.text.TextSnapshot"/></textSnapshot>
		<addChild public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></addChild>
		<addChildAt public="1" set="method"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<x path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></addChildAt>
		<areInaccessibleObjectsUnderPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<x path="Bool"/>
</f></areInaccessibleObjectsUnderPoint>
		<contains public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<x path="Bool"/>
</f></contains>
		<getChildAt public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildAt>
		<getChildByName public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildByName>
		<getChildIndex public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<x path="Int"/>
</f></getChildIndex>
		<getObjectsUnderPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="Array"><c path="flash.display.DisplayObject"/></c>
</f></getObjectsUnderPoint>
		<removeChild public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChild>
		<removeChildAt public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChildAt>
		<setChildIndex public="1" set="method"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setChildIndex>
		<swapChildren public="1" set="method"><f a="child1:child2">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
	<x path="Void"/>
</f></swapChildren>
		<swapChildrenAt public="1" set="method"><f a="index1:index2">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swapChildrenAt>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.display.Sprite" params="" file="C:\HaxeToolkit\haxe\std/flash/display/Sprite.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<buttonMode public="1"><x path="Bool"/></buttonMode>
		<dropTarget public="1" set="null"><c path="flash.display.DisplayObject"/></dropTarget>
		<graphics public="1" set="null"><c path="flash.display.Graphics"/></graphics>
		<hitArea public="1"><c path="flash.display.Sprite"/></hitArea>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<useHandCursor public="1"><x path="Bool"/></useHandCursor>
		<startDrag public="1" set="method"><f a="?lockCenter:?bounds">
	<x path="Bool"/>
	<c path="flash.geom.Rectangle"/>
	<x path="Void"/>
</f></startDrag>
		<stopDrag public="1" set="method"><f a=""><x path="Void"/></f></stopDrag>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="dl.socket.client.SockClientTchatUI" params="" file="src/dl/socket/client/SockClientTchatUI.hx">
		<extends path="flash.display.Sprite"/>
		<MARG_EXT public="1" line="22" static="1"><x path="Int"/></MARG_EXT>
		<MARG_INT public="1" line="23" static="1"><x path="Int"/></MARG_INT>
		<LIST_LARG public="1" line="24" static="1"><x path="Int"/></LIST_LARG>
		<sendMsg public="1"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></sendMsg>
		<_me><c path="dl.socket.client.SockClientUser"/></_me>
		<_others><c path="Array"><c path="dl.socket.client.SockClientUser"/></c></_others>
		<_room><c path="String"/></_room>
		<_input><c path="flash.text.TextField"/></_input>
		<_output><c path="flash.text.TextField"/></_output>
		<_list><c path="flash.text.TextField"/></_list>
		<onKeyUp set="method" line="79"><f a="e">
	<c path="flash.events.KeyboardEvent"/>
	<x path="Void"/>
</f></onKeyUp>
		<connect public="1" set="method" line="88"><f a="me">
	<c path="dl.socket.client.SockClientUser"/>
	<x path="Void"/>
</f></connect>
		<refreshMe public="1" set="method" line="98"><f a="me">
	<c path="dl.socket.client.SockClientUser"/>
	<x path="Void"/>
</f></refreshMe>
		<changeRoom public="1" get="inline" set="null" line="110"><f a="room:userList">
	<c path="String"/>
	<c path="Array"><c path="dl.socket.client.SockClientUser"/></c>
	<x path="Void"/>
</f></changeRoom>
		<cloneList get="inline" set="null" line="125"><f a="list">
	<c path="Array"><c path="dl.socket.client.SockClientUser"/></c>
	<c path="Array"><c path="dl.socket.client.SockClientUser"/></c>
</f></cloneList>
		<clear get="inline" set="null" line="133"><f a=""><x path="Void"/></f></clear>
		<appendTextAlign public="1" get="inline" set="null" line="139"><f a="t:?align" v=":'left'">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></appendTextAlign>
		<appendText public="1" get="inline" set="null" line="145"><f a="t">
	<c path="String"/>
	<x path="Void"/>
</f></appendText>
		<refreshOthers public="1" get="inline" set="null" line="150"><f a="list">
	<c path="Array"><c path="dl.socket.client.SockClientUser"/></c>
	<x path="Void"/>
</f></refreshOthers>
		<refreshRight set="method" line="190"><f a=""><x path="Void"/></f></refreshRight>
		<refreshText get="inline" set="null" line="206"><f a=""><x path="Void"/></f></refreshText>
		<resize public="1" set="method" line="211"><f a="?e" v="null">
	<d/>
	<x path="Void"/>
</f></resize>
		<new public="1" set="method" line="36"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Namide</haxe_doc>
	</class>
	<class path="dl.socket.client.SockClientUser" params="" file="src/dl/socket/client/SockClientUser.hx">
		<name public="1"><c path="String"/></name>
		<id public="1"><x path="Int"/></id>
		<datas public="1"><d/></datas>
		<role public="1"><x path="dl.socket.Role"/></role>
		<clone public="1" set="method" line="22"><f a=""><c path="dl.socket.client.SockClientUser"/></f></clone>
		<fullName public="1" get="inline" set="null" line="37"><f a=""><c path="String"/></f></fullName>
		<new public="1" set="method" line="17"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Namide</haxe_doc>
	</class>
	<class path="dl.socket.client.SockPipe" params="" file="src/dl/socket/client/SockPipe.hx">
		<_FIRST_INIT line="18" static="1"><x path="Bool"/></_FIRST_INIT>
		<firstInit set="method" line="19"><f a=""><x path="Void"/></f></firstInit>
		<_socket><c path="flash.net.Socket"/></_socket>
		<onReceive public="1"><f a="">
	<c path="dl.socket.SockMsg"/>
	<x path="Void"/>
</f></onReceive>
		<onConnected public="1"><f a="">
	<c path="dl.socket.client.SockPipe"/>
	<x path="Void"/>
</f></onConnected>
		<socketConnect set="method" line="48"><f a="e">
	<d/>
	<x path="Void"/>
</f></socketConnect>
		<send public="1" set="method" line="53"><f a="msg">
	<c path="dl.socket.SockMsg"/>
	<x path="Void"/>
</f></send>
		<socketData set="method" line="66"><f a="e">
	<c path="flash.events.ProgressEvent"/>
	<x path="Void"/>
</f></socketData>
		<socketClose set="method" line="80"><f a="e">
	<d/>
	<x path="Void"/>
</f></socketClose>
		<socketError set="method" line="85"><f a="e">
	<d/>
	<x path="Void"/>
</f></socketError>
		<close public="1" set="method" line="90"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="32"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Namide</haxe_doc>
	</class>
	<class path="dl.utils.Calcul" params="" file="src/dl/utils/Calcul.hx">
		<exposant public="1" get="inline" set="null" line="13" static="1"><f a="n:?pow" v=":2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></exposant>
		<exposantInt public="1" get="inline" set="null" line="17" static="1"><f a="n:?pow" v=":2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></exposantInt>
		<nextPow public="1" get="inline" set="null" line="21" static="1"><f a="n:?pow" v=":2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></nextPow>
		<new get="inline" set="null" line="9"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Namide</haxe_doc>
	</class>
	<class path="dl.utils.Name" params="" file="src/dl/utils/Name.hx">
		<getRandName public="1" set="method" line="15" static="1"><f a="charMin:charMax">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></getRandName>
		<new public="1" set="method" line="10"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Namide</haxe_doc>
	</class>
	<class path="dl.utils.Obj" params="" file="src/dl/utils/Obj.hx">
		<deepCopy public="1" params="T" set="method" line="17" static="1">
			<f a="v">
				<c path="deepCopy.T"/>
				<c path="deepCopy.T"/>
			</f>
			<haxe_doc>* deep copy of anything</haxe_doc>
		</deepCopy>
		<new public="1" set="method" line="10"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Namide</haxe_doc>
	</class>
	<typedef path="dl.utils.PosGrid" params="" file="src/dl/utils/PlatformLevelFactory.hx" module="dl.utils.PlatformLevelFactory"><a>
	<j><x path="Int"/></j>
	<i><x path="Int"/></i>
</a></typedef>
	<typedef path="dl.utils.Pos" params="" file="src/dl/utils/PlatformLevelFactory.hx" module="dl.utils.PlatformLevelFactory"><a>
	<y><x path="Float"/></y>
	<x><x path="Float"/></x>
</a></typedef>
	<typedef path="dl.utils.LevelDatas" params="" file="src/dl/utils/PlatformLevelFactory.hx" module="dl.utils.PlatformLevelFactory"><a>
	<tilesDatas><c path="Array"><t path="dl.utils.TileData"/></c></tilesDatas>
	<tileSize><x path="Float"/></tileSize>
	<playerDatas><t path="dl.utils.PlayerData"/></playerDatas>
	<levelGrid><c path="Array"><c path="Array"><x path="UInt"/></c></c></levelGrid>
</a></typedef>
	<typedef path="dl.utils.TileData" params="" file="src/dl/utils/PlatformLevelFactory.hx" module="dl.utils.PlatformLevelFactory"><a>
	<idFlag><x path="UInt"/></idFlag>
	<graphic>
		<t path="Null"><f a="">
	<c path="dl.physic.body.Body"/>
	<x path="Void"/>
</f></t>
		<meta><m n=":optional"/></meta>
	</graphic>
	<contacts><x path="dl.physic.contact.BodyContactsFlags"/></contacts>
</a></typedef>
	<typedef path="dl.utils.PlayerData" params="" file="src/dl/utils/PlatformLevelFactory.hx" module="dl.utils.PlatformLevelFactory"><a>
	<size><t path="dl.utils.Pos"/></size>
	<runTileSec><x path="Float"/></runTileSec>
	<posTile><t path="dl.utils.Pos"/></posTile>
	<physic><x path="dl.physic.move.BodyPhysicFlags"/></physic>
	<jumpTileWidthMin><x path="Float"/></jumpTileWidthMin>
	<jumpTileWidthMax><x path="Float"/></jumpTileWidthMax>
	<jumpTileHeightMin><x path="Float"/></jumpTileHeightMin>
	<jumpTileHeightMax><x path="Float"/></jumpTileHeightMax>
	<graphic>
		<t path="Null"><f a=":">
	<c path="dl.physic.body.Body"/>
	<c path="dl.input.PlatformPlayerController"/>
	<x path="Void"/>
</f></t>
		<meta><m n=":optional"/></meta>
	</graphic>
	<contacts><x path="dl.physic.contact.BodyContactsFlags"/></contacts>
</a></typedef>
	<class path="dl.utils.PlatformLevelFactory" params="" file="src/dl/utils/PlatformLevelFactory.hx">
		<_MAIN static="1"><c path="dl.utils.PlatformLevelFactory"/></_MAIN>
		<getInstance public="1" set="method" line="59" static="1"><f a=""><c path="dl.utils.PlatformLevelFactory"/></f></getInstance>
		<generate public="1" set="method" line="67"><f a="levelData:platformPhysicSystem">
	<t path="dl.utils.LevelDatas"/>
	<c path="dl.physic.move.PlatformPhysicSystem"/>
	<x path="Void"/>
</f></generate>
		<genPlayer public="1" set="method" line="76"><f a="playerData:gravity:tileSize">
	<t path="dl.utils.PlayerData"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></genPlayer>
		<genGrid public="1" set="method" line="95"><f a="grid:tilesData:size">
	<c path="Array"><c path="Array"><x path="UInt"/></c></c>
	<c path="Array"><t path="dl.utils.TileData"/></c>
	<x path="Float"/>
	<x path="Void"/>
</f></genGrid>
		<getTileById get="inline" set="null" line="116"><f a="id:tilesData">
	<x path="UInt"/>
	<c path="Array"><t path="dl.utils.TileData"/></c>
	<t path="Null"><t path="dl.utils.TileData"/></t>
</f></getTileById>
		<new set="method" line="57"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Construct a platform level from a LevelDatas TypeDef
 * 
 * @author Namide</haxe_doc>
	</class>
	<class path="dl.utils.Timer" params="" file="src/dl/utils/Timer.hx">
		<STAGE static="1"><c path="flash.display.Stage"/></STAGE>
		<getRealSec public="1" get="inline" set="null" line="69" static="1"><f a=""><x path="Float"/></f></getRealSec>
		<_realT><x path="Float"/></_realT>
		<frameRest public="1" set="null"><x path="Float"/></frameRest>
		<frameTime public="1" set="null"><x path="Float"/></frameTime>
		<pause public="1"><x path="Bool"/></pause>
		<dtSec public="1" set="null"><x path="Float"/></dtSec>
		<distord public="1"><x path="Float"/></distord>
		<onFrameUpdate public="1"><f a=":">
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></onFrameUpdate>
		<dispose public="1" set="method" line="37"><f a=""><x path="Void"/></f></dispose>
		<update set="method" line="42"><f a="?e" v="null">
	<d/>
	<x path="Void"/>
</f></update>
		<restart public="1" set="method" line="67"><f a=""><x path="Void"/></f></restart>
		<new public="1" set="method" line="22"><f a="?FPS:?sec" v="50:0">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Namide</haxe_doc>
	</class>
	<class path="flash.display.MovieClip" params="" file="C:\HaxeToolkit\haxe\std/flash/display/MovieClip.hx" extern="1">
		<extends path="flash.display.Sprite"/>
		<currentFrame public="1" set="null"><x path="Int"/></currentFrame>
		<currentFrameLabel public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</currentFrameLabel>
		<currentLabel public="1" set="null"><c path="String"/></currentLabel>
		<currentLabels public="1" set="null"><c path="Array"><c path="flash.display.FrameLabel"/></c></currentLabels>
		<currentScene public="1" set="null"><c path="flash.display.Scene"/></currentScene>
		<enabled public="1"><x path="Bool"/></enabled>
		<framesLoaded public="1" set="null"><x path="Int"/></framesLoaded>
		<scenes public="1" set="null"><c path="Array"><c path="flash.display.Scene"/></c></scenes>
		<totalFrames public="1" set="null"><x path="Int"/></totalFrames>
		<trackAsMenu public="1"><x path="Bool"/></trackAsMenu>
		<addFrameScript public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></addFrameScript>
		<gotoAndPlay public="1" set="method"><f a="frame:?scene">
	<t path="flash.utils.Object"/>
	<c path="String"/>
	<x path="Void"/>
</f></gotoAndPlay>
		<gotoAndStop public="1" set="method"><f a="frame:?scene">
	<t path="flash.utils.Object"/>
	<c path="String"/>
	<x path="Void"/>
</f></gotoAndStop>
		<nextFrame public="1" set="method"><f a=""><x path="Void"/></f></nextFrame>
		<nextScene public="1" set="method"><f a=""><x path="Void"/></f></nextScene>
		<play public="1" set="method"><f a=""><x path="Void"/></f></play>
		<prevFrame public="1" set="method"><f a=""><x path="Void"/></f></prevFrame>
		<prevScene public="1" set="method"><f a=""><x path="Void"/></f></prevScene>
		<stop public="1" set="method"><f a=""><x path="Void"/></f></stop>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.Boot" params="" file="C:\HaxeToolkit\haxe\std/flash/Boot.hx">
		<extends path="flash.display.MovieClip"/>
		<tf static="1"><c path="flash.text.TextField"/></tf>
		<lines static="1"><c path="Array"><c path="String"/></c></lines>
		<lastError static="1"><c path="flash.errors.Error"/></lastError>
		<skip_constructor public="1" line="51" static="1"><x path="Bool"/></skip_constructor>
		<enum_to_string public="1" set="method" line="83" static="1"><f a="e">
	<a>
		<tag><c path="String"/></tag>
		<params><c path="Array"><d/></c></params>
	</a>
	<c path="String"/>
</f></enum_to_string>
		<__instanceof public="1" set="method" line="92" static="1"><f a="v:t">
	<d/>
	<d/>
	<x path="Bool"/>
</f></__instanceof>
		<__clear_trace public="1" set="method" line="102" static="1"><f a=""><x path="Void"/></f></__clear_trace>
		<__set_trace_color public="1" set="method" line="110" static="1"><f a="rgb">
	<x path="UInt"/>
	<x path="Void"/>
</f></__set_trace_color>
		<getTrace public="1" set="method" line="116" static="1"><f a=""><c path="flash.text.TextField"/></f></getTrace>
		<__trace public="1" set="method" line="144" static="1"><f a="v:pos">
	<d/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></__trace>
		<__string_rec public="1" set="method" line="163" static="1"><f a="v:str">
	<d/>
	<c path="String"/>
	<c path="String"/>
</f></__string_rec>
		<__unprotect__ set="method" line="208" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></__unprotect__>
		<start set="method" line="53"><f a=""><x path="Void"/></f></start>
		<doInitDelay set="method" line="74"><f a="_">
	<unknown/>
	<x path="Void"/>
</f></doInitDelay>
		<init set="method" line="79"><f a=""><x path="Void"/></f></init>
		<new public="1" set="method" line="45"><f a=""><x path="Void"/></f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="flash._Boot.RealBoot" params="" file="C:\HaxeToolkit\haxe\std/flash/Boot.hx" private="1" module="flash.Boot">
		<extends path="flash.Boot"/>
		<new set="method" line="35"><f a=""><x path="Void"/></f></new>
		<meta><m n=":keep"/></meta>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.Lib" params="" file="C:\HaxeToolkit\haxe\std/flash/Lib.hx">
		<current public="1" static="1"><c path="flash.display.MovieClip"/></current>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="flash.Vector" params="T" file="C:\HaxeToolkit\haxe\std/flash/Vector.hx" extern="1">
		<ofArray public="1" params="T" get="inline" set="null" line="47" static="1"><f a="v">
	<c path="Array"><c path="ofArray.T"/></c>
	<c path="flash.Vector"><c path="ofArray.T"/></c>
</f></ofArray>
		<convert public="1" params="T:U" get="inline" set="null" line="51" static="1"><f a="v">
	<c path="flash.Vector"><c path="convert.T"/></c>
	<c path="flash.Vector"><c path="convert.U"/></c>
</f></convert>
		<length public="1"><x path="Int"/></length>
		<fixed public="1"><x path="Bool"/></fixed>
		<concat public="1" set="method"><f a="?a">
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></concat>
		<join public="1" set="method"><f a="sep">
	<c path="String"/>
	<c path="String"/>
</f></join>
		<pop public="1" set="method"><f a=""><t path="Null"><c path="flash.Vector.T"/></t></f></pop>
		<push public="1" set="method"><f a="x">
	<c path="flash.Vector.T"/>
	<x path="Int"/>
</f></push>
		<reverse public="1" set="method"><f a=""><x path="Void"/></f></reverse>
		<shift public="1" set="method"><f a=""><t path="Null"><c path="flash.Vector.T"/></t></f></shift>
		<unshift public="1" set="method"><f a="x">
	<c path="flash.Vector.T"/>
	<x path="Void"/>
</f></unshift>
		<slice public="1" set="method"><f a="?pos:?end">
	<x path="Int"/>
	<x path="Int"/>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></slice>
		<sort public="1" set="method"><f a="f">
	<f a=":">
		<c path="flash.Vector.T"/>
		<c path="flash.Vector.T"/>
		<x path="Int"/>
	</f>
	<x path="Void"/>
</f></sort>
		<splice public="1" set="method"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></splice>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<indexOf public="1" set="method"><f a="x:?from">
	<c path="flash.Vector.T"/>
	<x path="Int"/>
	<x path="Int"/>
</f></indexOf>
		<lastIndexOf public="1" set="method"><f a="x:?from">
	<c path="flash.Vector.T"/>
	<x path="Int"/>
	<x path="Int"/>
</f></lastIndexOf>
		<new public="1" set="method"><f a="?length:?fixed">
	<x path="UInt"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>The Vector class is very similar to Array but is only supported by the Flash Player 10+</haxe_doc>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.accessibility.AccessibilityImplementation" params="" file="C:\HaxeToolkit\haxe\std/flash/accessibility/AccessibilityImplementation.hx" extern="1">
		<errno public="1"><x path="UInt"/></errno>
		<stub public="1"><x path="Bool"/></stub>
		<accDoDefaultAction public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<x path="Void"/>
</f></accDoDefaultAction>
		<accLocation public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<d/>
</f></accLocation>
		<accSelect public="1" set="method"><f a="operation:childID">
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></accSelect>
		<getChildIDArray public="1" set="method"><f a=""><c path="Array"><d/></c></f></getChildIDArray>
		<get_accDefaultAction public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<c path="String"/>
</f></get_accDefaultAction>
		<get_accFocus public="1" set="method"><f a=""><x path="UInt"/></f></get_accFocus>
		<get_accName public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<c path="String"/>
</f></get_accName>
		<get_accRole public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<x path="UInt"/>
</f></get_accRole>
		<get_accSelection public="1" set="method"><f a=""><c path="Array"><d/></c></f></get_accSelection>
		<get_accState public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<x path="UInt"/>
</f></get_accState>
		<get_accValue public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<c path="String"/>
</f></get_accValue>
		<get_selectionActiveIndex public="1" set="method"><f a=""><d/></f></get_selectionActiveIndex>
		<get_selectionAnchorIndex public="1" set="method"><f a=""><d/></f></get_selectionAnchorIndex>
		<isLabeledBy public="1" set="method"><f a="labelBounds">
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
</f></isLabeledBy>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.accessibility.AccessibilityProperties" params="" file="C:\HaxeToolkit\haxe\std/flash/accessibility/AccessibilityProperties.hx" extern="1">
		<description public="1"><c path="String"/></description>
		<forceSimple public="1"><x path="Bool"/></forceSimple>
		<name public="1"><c path="String"/></name>
		<noAutoLabeling public="1"><x path="Bool"/></noAutoLabeling>
		<shortcut public="1"><c path="String"/></shortcut>
		<silent public="1"><x path="Bool"/></silent>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<enum path="flash.display.ActionScriptVersion" params="" file="C:\HaxeToolkit\haxe\std/flash/display/ActionScriptVersion.hx">
		<ACTIONSCRIPT2/>
		<ACTIONSCRIPT3/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>UInt</e></m>
		</meta>
	</enum>
	<class path="flash.display.BitmapData" params="" file="C:\HaxeToolkit\haxe\std/flash/display/BitmapData.hx" extern="1">
		<implements path="flash.display.IBitmapDrawable"/>
		<height public="1" set="null"><x path="Int"/></height>
		<rect public="1" set="null"><c path="flash.geom.Rectangle"/></rect>
		<transparent public="1" set="null"><x path="Bool"/></transparent>
		<width public="1" set="null"><x path="Int"/></width>
		<applyFilter public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:filter">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.filters.BitmapFilter"/>
	<x path="Void"/>
</f></applyFilter>
		<clone public="1" set="method"><f a=""><c path="flash.display.BitmapData"/></f></clone>
		<colorTransform public="1" set="method"><f a="rect:colorTransform">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.ColorTransform"/>
	<x path="Void"/>
</f></colorTransform>
		<compare public="1" set="method"><f a="otherBitmapData">
	<c path="flash.display.BitmapData"/>
	<t path="flash.utils.Object"/>
</f></compare>
		<copyChannel public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:sourceChannel:destChannel">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></copyChannel>
		<copyPixels public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?alphaBitmapData:?alphaPoint:?mergeAlpha">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Point"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></copyPixels>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<draw public="1" set="method"><f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing">
	<c path="flash.display.IBitmapDrawable"/>
	<c path="flash.geom.Matrix"/>
	<c path="flash.geom.ColorTransform"/>
	<e path="flash.display.BlendMode"/>
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></draw>
		<fillRect public="1" set="method"><f a="rect:color">
	<c path="flash.geom.Rectangle"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></fillRect>
		<floodFill public="1" set="method"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></floodFill>
		<generateFilterRect public="1" set="method"><f a="sourceRect:filter">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.filters.BitmapFilter"/>
	<c path="flash.geom.Rectangle"/>
</f></generateFilterRect>
		<getColorBoundsRect public="1" set="method"><f a="mask:color:?findColor">
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Bool"/>
	<c path="flash.geom.Rectangle"/>
</f></getColorBoundsRect>
		<getPixel public="1" set="method"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
</f></getPixel>
		<getPixel32 public="1" set="method"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
</f></getPixel32>
		<getPixels public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
</f></getPixels>
		<getVector public="1" set="method">
			<f a="rect">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><x path="UInt"/></c>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</getVector>
		<histogram public="1" set="method">
			<f a="?hRect">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><c path="flash.Vector"><x path="Float"/></c></c>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</histogram>
		<hitTest public="1" set="method"><f a="firstPoint:firstAlphaThreshold:secondObject:?secondBitmapDataPoint:?secondAlphaThreshold">
	<c path="flash.geom.Point"/>
	<x path="UInt"/>
	<t path="flash.utils.Object"/>
	<c path="flash.geom.Point"/>
	<x path="UInt"/>
	<x path="Bool"/>
</f></hitTest>
		<lock public="1" set="method"><f a=""><x path="Void"/></f></lock>
		<merge public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:redMultiplier:greenMultiplier:blueMultiplier:alphaMultiplier">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></merge>
		<noise public="1" set="method"><f a="randomSeed:?low:?high:?channelOptions:?grayScale">
	<x path="Int"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></noise>
		<paletteMap public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?redArray:?greenArray:?blueArray:?alphaArray">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></paletteMap>
		<perlinNoise public="1" set="method"><f a="baseX:baseY:numOctaves:randomSeed:stitch:fractalNoise:?channelOptions:?grayScale:?offsets">
	<x path="Float"/>
	<x path="Float"/>
	<x path="UInt"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="UInt"/>
	<x path="Bool"/>
	<c path="Array"><c path="flash.geom.Point"/></c>
	<x path="Void"/>
</f></perlinNoise>
		<pixelDissolve public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?randomSeed:?numPixels:?fillColor">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
	<x path="Int"/>
</f></pixelDissolve>
		<scroll public="1" set="method"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></scroll>
		<setPixel public="1" set="method"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></setPixel>
		<setPixel32 public="1" set="method"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></setPixel32>
		<setPixels public="1" set="method"><f a="rect:inputByteArray">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></setPixels>
		<setVector public="1" set="method">
			<f a="rect:inputVector">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><x path="UInt"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</setVector>
		<threshold public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:operation:threshold:?color:?mask:?copySource">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="String"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Bool"/>
	<x path="UInt"/>
</f></threshold>
		<unlock public="1" set="method"><f a="?changeRect">
	<c path="flash.geom.Rectangle"/>
	<x path="Void"/>
</f></unlock>
		<new public="1" set="method"><f a="width:height:?transparent:?fillColor">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="flash.display.BlendMode" params="" file="C:\HaxeToolkit\haxe\std/flash/display/BlendMode.hx">
		<ADD/>
		<ALPHA/>
		<DARKEN/>
		<DIFFERENCE/>
		<ERASE/>
		<HARDLIGHT/>
		<INVERT/>
		<LAYER/>
		<LIGHTEN/>
		<MULTIPLY/>
		<NORMAL/>
		<OVERLAY/>
		<SCREEN/>
		<SHADER/>
		<SUBTRACT/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display.CapsStyle" params="" file="C:\HaxeToolkit\haxe\std/flash/display/CapsStyle.hx">
		<NONE/>
		<ROUND/>
		<SQUARE/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display.ColorCorrection" params="" file="C:\HaxeToolkit\haxe\std/flash/display/ColorCorrection.hx">
		<DEFAULT/>
		<OFF/>
		<ON/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</enum>
	<enum path="flash.display.ColorCorrectionSupport" params="" file="C:\HaxeToolkit\haxe\std/flash/display/ColorCorrectionSupport.hx">
		<DEFAULT_OFF/>
		<DEFAULT_ON/>
		<UNSUPPORTED/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</enum>
	<class path="flash.display.FrameLabel" params="" file="C:\HaxeToolkit\haxe\std/flash/display/FrameLabel.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<frame public="1" set="null"><x path="Int"/></frame>
		<name public="1" set="null"><c path="String"/></name>
		<new public="1" set="method"><f a="name:frame">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display.GradientType" params="" file="C:\HaxeToolkit\haxe\std/flash/display/GradientType.hx">
		<LINEAR/>
		<RADIAL/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.display.Graphics" params="" file="C:\HaxeToolkit\haxe\std/flash/display/Graphics.hx" extern="1">
		<beginBitmapFill public="1" set="method"><f a="bitmap:?matrix:?repeat:?smooth">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Matrix"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></beginBitmapFill>
		<beginFill public="1" set="method"><f a="color:?alpha">
	<x path="UInt"/>
	<x path="Float"/>
	<x path="Void"/>
</f></beginFill>
		<beginGradientFill public="1" set="method"><f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio">
	<e path="flash.display.GradientType"/>
	<c path="Array"><x path="UInt"/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="flash.geom.Matrix"/>
	<e path="flash.display.SpreadMethod"/>
	<e path="flash.display.InterpolationMethod"/>
	<x path="Float"/>
	<x path="Void"/>
</f></beginGradientFill>
		<beginShaderFill public="1" set="method">
			<f a="shader:?matrix">
				<c path="flash.display.Shader"/>
				<c path="flash.geom.Matrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</beginShaderFill>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<copyFrom public="1" set="method">
			<f a="sourceGraphics">
				<c path="flash.display.Graphics"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</copyFrom>
		<curveTo public="1" set="method"><f a="controlX:controlY:anchorX:anchorY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></curveTo>
		<drawCircle public="1" set="method"><f a="x:y:radius">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawCircle>
		<drawEllipse public="1" set="method"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawEllipse>
		<drawGraphicsData public="1" set="method">
			<f a="graphicsData">
				<c path="flash.Vector"><c path="flash.display.IGraphicsData"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawGraphicsData>
		<drawPath public="1" set="method">
			<f a="commands:data:?winding">
				<c path="flash.Vector"><x path="Int"/></c>
				<c path="flash.Vector"><x path="Float"/></c>
				<e path="flash.display.GraphicsPathWinding"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawPath>
		<drawRect public="1" set="method"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRect>
		<drawRoundRect public="1" set="method"><f a="x:y:width:height:ellipseWidth:?ellipseHeight">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRoundRect>
		<drawRoundRectComplex public="1" set="method"><f a="x:y:width:height:topLeftRadius:topRightRadius:bottomLeftRadius:bottomRightRadius">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRoundRectComplex>
		<drawTriangles public="1" set="method">
			<f a="vertices:?indices:?uvtData:?culling">
				<c path="flash.Vector"><x path="Float"/></c>
				<c path="flash.Vector"><x path="Int"/></c>
				<c path="flash.Vector"><x path="Float"/></c>
				<e path="flash.display.TriangleCulling"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawTriangles>
		<endFill public="1" set="method"><f a=""><x path="Void"/></f></endFill>
		<lineBitmapStyle public="1" set="method">
			<f a="bitmap:?matrix:?repeat:?smooth">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Matrix"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</lineBitmapStyle>
		<lineGradientStyle public="1" set="method"><f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio">
	<e path="flash.display.GradientType"/>
	<c path="Array"><x path="UInt"/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="flash.geom.Matrix"/>
	<e path="flash.display.SpreadMethod"/>
	<e path="flash.display.InterpolationMethod"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineGradientStyle>
		<lineShaderStyle public="1" set="method">
			<f a="shader:?matrix">
				<c path="flash.display.Shader"/>
				<c path="flash.geom.Matrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</lineShaderStyle>
		<lineStyle public="1" set="method"><f a="?thickness:?color:?alpha:?pixelHinting:?scaleMode:?caps:?joints:?miterLimit">
	<x path="Float"/>
	<x path="UInt"/>
	<x path="Float"/>
	<x path="Bool"/>
	<e path="flash.display.LineScaleMode"/>
	<e path="flash.display.CapsStyle"/>
	<e path="flash.display.JointStyle"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineStyle>
		<lineTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<moveTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display.GraphicsPathWinding" params="" file="C:\HaxeToolkit\haxe\std/flash/display/GraphicsPathWinding.hx">
		<EVEN_ODD/>
		<NON_ZERO/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.display.IGraphicsData" params="" file="C:\HaxeToolkit\haxe\std/flash/display/IGraphicsData.hx" extern="1" interface="1"/>
	<enum path="flash.display.InterpolationMethod" params="" file="C:\HaxeToolkit\haxe\std/flash/display/InterpolationMethod.hx">
		<LINEAR_RGB/>
		<RGB/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display.JointStyle" params="" file="C:\HaxeToolkit\haxe\std/flash/display/JointStyle.hx">
		<BEVEL/>
		<MITER/>
		<ROUND/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display.LineScaleMode" params="" file="C:\HaxeToolkit\haxe\std/flash/display/LineScaleMode.hx">
		<HORIZONTAL/>
		<NONE/>
		<NORMAL/>
		<VERTICAL/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.display.Loader" params="" file="C:\HaxeToolkit\haxe\std/flash/display/Loader.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<content public="1" set="null"><c path="flash.display.DisplayObject"/></content>
		<contentLoaderInfo public="1" set="null"><c path="flash.display.LoaderInfo"/></contentLoaderInfo>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<load public="1" set="method"><f a="request:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.system.LoaderContext"/>
	<x path="Void"/>
</f></load>
		<loadBytes public="1" set="method"><f a="bytes:?context">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.system.LoaderContext"/>
	<x path="Void"/>
</f></loadBytes>
		<unload public="1" set="method"><f a=""><x path="Void"/></f></unload>
		<unloadAndStop public="1" set="method">
			<f a="?gc">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</unloadAndStop>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.display.LoaderInfo" params="" file="C:\HaxeToolkit\haxe\std/flash/display/LoaderInfo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<getLoaderInfoByDefinition public="1" set="method" static="1"><f a="object">
	<d/>
	<c path="flash.display.LoaderInfo"/>
</f></getLoaderInfoByDefinition>
		<actionScriptVersion public="1" set="null"><e path="flash.display.ActionScriptVersion"/></actionScriptVersion>
		<applicationDomain public="1" set="null"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<bytes public="1" set="null"><c path="flash.utils.ByteArray"/></bytes>
		<bytesLoaded public="1" set="null"><x path="UInt"/></bytesLoaded>
		<bytesTotal public="1" set="null"><x path="UInt"/></bytesTotal>
		<childAllowsParent public="1" set="null"><x path="Bool"/></childAllowsParent>
		<content public="1" set="null"><c path="flash.display.DisplayObject"/></content>
		<contentType public="1" set="null"><c path="String"/></contentType>
		<frameRate public="1" set="null"><x path="Float"/></frameRate>
		<height public="1" set="null"><x path="Int"/></height>
		<loader public="1" set="null"><c path="flash.display.Loader"/></loader>
		<loaderURL public="1" set="null"><c path="String"/></loaderURL>
		<parameters public="1" set="null"><d><c path="String"/></d></parameters>
		<parentAllowsChild public="1" set="null"><x path="Bool"/></parentAllowsChild>
		<sameDomain public="1" set="null"><x path="Bool"/></sameDomain>
		<sharedEvents public="1" set="null"><c path="flash.events.EventDispatcher"/></sharedEvents>
		<swfVersion public="1" set="null"><x path="UInt"/></swfVersion>
		<url public="1" set="null"><c path="String"/></url>
		<width public="1" set="null"><x path="Int"/></width>
	</class>
	<class path="flash.display.NativeMenu" params="" file="C:\HaxeToolkit\haxe\std/flash/display/NativeMenu.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<new public="1"><f a=""><x path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_1</e></m></meta>
	</class>
	<class path="flash.display.Scene" params="" file="C:\HaxeToolkit\haxe\std/flash/display/Scene.hx" extern="1">
		<labels public="1" set="null"><c path="Array"><c path="flash.display.FrameLabel"/></c></labels>
		<name public="1" set="null"><c path="String"/></name>
		<numFrames public="1" set="null"><x path="Int"/></numFrames>
		<new public="1" set="method"><f a="name:labels:numFrames">
	<c path="String"/>
	<c path="Array"><c path="flash.display.FrameLabel"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display.Shader" params="" file="C:\HaxeToolkit\haxe\std/flash/display/Shader.hx" extern="1">
		<byteCode public="1" get="null"><c path="flash.utils.ByteArray"/></byteCode>
		<data public="1"><c path="flash.display.ShaderData"/></data>
		<precisionHint public="1"><e path="flash.display.ShaderPrecision"/></precisionHint>
		<new public="1" set="method"><f a="?code">
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.display.ShaderData" params="" file="C:\HaxeToolkit\haxe\std/flash/display/ShaderData.hx" extern="1">
		<new public="1" set="method"><f a="byteCode">
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="flash.display.ShaderPrecision" params="" file="C:\HaxeToolkit\haxe\std/flash/display/ShaderPrecision.hx">
		<FAST/>
		<FULL/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display.SpreadMethod" params="" file="C:\HaxeToolkit\haxe\std/flash/display/SpreadMethod.hx">
		<PAD/>
		<REFLECT/>
		<REPEAT/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.display.Stage" params="" file="C:\HaxeToolkit\haxe\std/flash/display/Stage.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<align public="1"><e path="flash.display.StageAlign"/></align>
		<colorCorrection public="1">
			<e path="flash.display.ColorCorrection"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</colorCorrection>
		<colorCorrectionSupport public="1" set="null">
			<e path="flash.display.ColorCorrectionSupport"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</colorCorrectionSupport>
		<displayState public="1"><e path="flash.display.StageDisplayState"/></displayState>
		<focus public="1"><c path="flash.display.InteractiveObject"/></focus>
		<frameRate public="1"><x path="Float"/></frameRate>
		<fullScreenHeight public="1" set="null"><x path="UInt"/></fullScreenHeight>
		<fullScreenSourceRect public="1"><c path="flash.geom.Rectangle"/></fullScreenSourceRect>
		<fullScreenWidth public="1" set="null"><x path="UInt"/></fullScreenWidth>
		<quality public="1"><e path="flash.display.StageQuality"/></quality>
		<scaleMode public="1"><e path="flash.display.StageScaleMode"/></scaleMode>
		<showDefaultContextMenu public="1"><x path="Bool"/></showDefaultContextMenu>
		<stageFocusRect public="1"><x path="Bool"/></stageFocusRect>
		<stageHeight public="1"><x path="Int"/></stageHeight>
		<stageWidth public="1"><x path="Int"/></stageWidth>
		<invalidate public="1" set="method"><f a=""><x path="Void"/></f></invalidate>
		<isFocusInaccessible public="1" set="method"><f a=""><x path="Bool"/></f></isFocusInaccessible>
	</class>
	<class path="flash.display.Stage3D" params="" file="C:\HaxeToolkit\haxe\std/flash/display/Stage3D.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<context3D public="1" set="null"><c path="flash.display3D.Context3D"/></context3D>
		<visible public="1"><x path="Bool"/></visible>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<requestContext3D public="1" set="method"><f a="?context3DRenderMode:?profile">
	<c path="String"/>
	<e path="flash.display3D.Context3DProfile"/>
	<x path="Void"/>
</f></requestContext3D>
		<meta><m n=":require"><e>flash11</e></m></meta>
	</class>
	<enum path="flash.display.StageAlign" params="" file="C:\HaxeToolkit\haxe\std/flash/display/StageAlign.hx">
		<BOTTOM/>
		<BOTTOM_LEFT/>
		<BOTTOM_RIGHT/>
		<LEFT/>
		<RIGHT/>
		<TOP/>
		<TOP_LEFT/>
		<TOP_RIGHT/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display.StageDisplayState" params="" file="C:\HaxeToolkit\haxe\std/flash/display/StageDisplayState.hx">
		<FULL_SCREEN/>
		<FULL_SCREEN_INTERACTIVE/>
		<NORMAL/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display.StageQuality" params="" file="C:\HaxeToolkit\haxe\std/flash/display/StageQuality.hx">
		<BEST/>
		<HIGH/>
		<HIGH_16X16/>
		<HIGH_16X16_LINEAR/>
		<HIGH_8X8/>
		<HIGH_8X8_LINEAR/>
		<LOW/>
		<MEDIUM/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display.StageScaleMode" params="" file="C:\HaxeToolkit\haxe\std/flash/display/StageScaleMode.hx">
		<EXACT_FIT/>
		<NO_BORDER/>
		<NO_SCALE/>
		<SHOW_ALL/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display.TriangleCulling" params="" file="C:\HaxeToolkit\haxe\std/flash/display/TriangleCulling.hx">
		<NEGATIVE/>
		<NONE/>
		<POSITIVE/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.display3D.Context3D" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3D.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<driverInfo public="1" set="null"><c path="String"/></driverInfo>
		<enableErrorChecking public="1"><x path="Bool"/></enableErrorChecking>
		<clear public="1" set="method"><f a="?red:?green:?blue:?alpha:?depth:?stencil:?mask">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></clear>
		<configureBackBuffer public="1" set="method"><f a="width:height:antiAlias:?enableDepthAndStencil:?wantsBestResolution">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></configureBackBuffer>
		<createCubeTexture public="1" set="method"><f a="size:format:optimizeForRenderToTexture:?streamingLevels">
	<x path="Int"/>
	<e path="flash.display3D.Context3DTextureFormat"/>
	<x path="Bool"/>
	<x path="Int"/>
	<c path="flash.display3D.textures.CubeTexture"/>
</f></createCubeTexture>
		<createIndexBuffer public="1" set="method"><f a="numIndices">
	<x path="Int"/>
	<c path="flash.display3D.IndexBuffer3D"/>
</f></createIndexBuffer>
		<createProgram public="1" set="method"><f a=""><c path="flash.display3D.Program3D"/></f></createProgram>
		<createTexture public="1" set="method"><f a="width:height:format:optimizeForRenderToTexture:?streamingLevels">
	<x path="Int"/>
	<x path="Int"/>
	<e path="flash.display3D.Context3DTextureFormat"/>
	<x path="Bool"/>
	<x path="Int"/>
	<c path="flash.display3D.textures.Texture"/>
</f></createTexture>
		<createVertexBuffer public="1" set="method"><f a="numVertices:data32PerVertex">
	<x path="Int"/>
	<x path="Int"/>
	<c path="flash.display3D.VertexBuffer3D"/>
</f></createVertexBuffer>
		<dispose public="1" set="method"><f a="?recreate">
	<x path="Bool"/>
	<x path="Void"/>
</f></dispose>
		<drawToBitmapData public="1" set="method"><f a="destination">
	<c path="flash.display.BitmapData"/>
	<x path="Void"/>
</f></drawToBitmapData>
		<drawTriangles public="1" set="method"><f a="indexBuffer:?firstIndex:?numTriangles">
	<c path="flash.display3D.IndexBuffer3D"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawTriangles>
		<present public="1" set="method"><f a=""><x path="Void"/></f></present>
		<setBlendFactors public="1" set="method"><f a="sourceFactor:destinationFactor">
	<e path="flash.display3D.Context3DBlendFactor"/>
	<e path="flash.display3D.Context3DBlendFactor"/>
	<x path="Void"/>
</f></setBlendFactors>
		<setColorMask public="1" set="method"><f a="red:green:blue:alpha">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setColorMask>
		<setCulling public="1" set="method"><f a="triangleFaceToCull">
	<e path="flash.display3D.Context3DTriangleFace"/>
	<x path="Void"/>
</f></setCulling>
		<setDepthTest public="1" set="method"><f a="depthMask:passCompareMode">
	<x path="Bool"/>
	<e path="flash.display3D.Context3DCompareMode"/>
	<x path="Void"/>
</f></setDepthTest>
		<setProgram public="1" set="method"><f a="program">
	<c path="flash.display3D.Program3D"/>
	<x path="Void"/>
</f></setProgram>
		<setProgramConstantsFromMatrix public="1" set="method"><f a="programType:firstRegister:matrix:?transposedMatrix">
	<e path="flash.display3D.Context3DProgramType"/>
	<x path="Int"/>
	<c path="flash.geom.Matrix3D"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setProgramConstantsFromMatrix>
		<setProgramConstantsFromVector public="1" set="method"><f a="programType:firstRegister:data:?numRegisters">
	<e path="flash.display3D.Context3DProgramType"/>
	<x path="Int"/>
	<c path="flash.Vector"><x path="Float"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></setProgramConstantsFromVector>
		<setRenderToBackBuffer public="1" set="method"><f a=""><x path="Void"/></f></setRenderToBackBuffer>
		<setRenderToTexture public="1" set="method"><f a="texture:?enableDepthAndStencil:?antiAlias:?surfaceSelector">
	<c path="flash.display3D.textures.TextureBase"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setRenderToTexture>
		<setScissorRectangle public="1" set="method"><f a="rectangle">
	<c path="flash.geom.Rectangle"/>
	<x path="Void"/>
</f></setScissorRectangle>
		<setStencilActions public="1" set="method"><f a="?triangleFace:?compareMode:?actionOnBothPass:?actionOnDepthFail:?actionOnDepthPassStencilFail">
	<e path="flash.display3D.Context3DTriangleFace"/>
	<e path="flash.display3D.Context3DCompareMode"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<x path="Void"/>
</f></setStencilActions>
		<setStencilReferenceValue public="1" set="method"><f a="referenceValue:?readMask:?writeMask">
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></setStencilReferenceValue>
		<setTextureAt public="1" set="method"><f a="sampler:texture">
	<x path="Int"/>
	<c path="flash.display3D.textures.TextureBase"/>
	<x path="Void"/>
</f></setTextureAt>
		<setVertexBufferAt public="1" set="method"><f a="index:buffer:?bufferOffset:?format">
	<x path="Int"/>
	<c path="flash.display3D.VertexBuffer3D"/>
	<x path="Int"/>
	<e path="flash.display3D.Context3DVertexBufferFormat"/>
	<x path="Void"/>
</f></setVertexBufferAt>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display3D.Context3DBlendFactor" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DBlendFactor.hx">
		<DESTINATION_ALPHA/>
		<DESTINATION_COLOR/>
		<ONE/>
		<ONE_MINUS_DESTINATION_ALPHA/>
		<ONE_MINUS_DESTINATION_COLOR/>
		<ONE_MINUS_SOURCE_ALPHA/>
		<ONE_MINUS_SOURCE_COLOR/>
		<SOURCE_ALPHA/>
		<SOURCE_COLOR/>
		<ZERO/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display3D.Context3DCompareMode" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DCompareMode.hx">
		<ALWAYS/>
		<EQUAL/>
		<GREATER/>
		<GREATER_EQUAL/>
		<LESS/>
		<LESS_EQUAL/>
		<NEVER/>
		<NOT_EQUAL/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display3D.Context3DMipFilter" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DMipFilter.hx">
		<MIPLINEAR/>
		<MIPNEAREST/>
		<MIPNONE/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display3D.Context3DProfile" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DProfile.hx">
		<BASELINE/>
		<BASELINE_CONSTRAINED/>
		<BASELINE_EXTENDED/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display3D.Context3DProgramType" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DProgramType.hx">
		<FRAGMENT/>
		<VERTEX/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display3D.Context3DStencilAction" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DStencilAction.hx">
		<DECREMENT_SATURATE/>
		<DECREMENT_WRAP/>
		<INCREMENT_SATURATE/>
		<INCREMENT_WRAP/>
		<INVERT/>
		<KEEP/>
		<SET/>
		<ZERO/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display3D.Context3DTextureFilter" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DTextureFilter.hx">
		<LINEAR/>
		<NEAREST/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display3D.Context3DTextureFormat" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DTextureFormat.hx">
		<BGRA/>
		<BGRA_PACKED/>
		<BGR_PACKED/>
		<COMPRESSED/>
		<COMPRESSED_ALPHA/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display3D.Context3DTriangleFace" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DTriangleFace.hx">
		<BACK/>
		<FRONT/>
		<FRONT_AND_BACK/>
		<NONE/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display3D.Context3DVertexBufferFormat" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DVertexBufferFormat.hx">
		<BYTES_4/>
		<FLOAT_1/>
		<FLOAT_2/>
		<FLOAT_3/>
		<FLOAT_4/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display3D.Context3DWrapMode" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Context3DWrapMode.hx">
		<CLAMP/>
		<REPEAT/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.display3D.IndexBuffer3D" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/IndexBuffer3D.hx" extern="1">
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:startOffset:count">
	<c path="flash.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromByteArray>
		<uploadFromVector public="1" set="method"><f a="data:startOffset:count">
	<c path="flash.Vector"><x path="UInt"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromVector>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.Program3D" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/Program3D.hx" extern="1">
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<upload public="1" set="method"><f a="vertexProgram:fragmentProgram">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></upload>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.VertexBuffer3D" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/VertexBuffer3D.hx" extern="1">
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:startVertex:numVertices">
	<c path="flash.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromByteArray>
		<uploadFromVector public="1" set="method"><f a="data:startVertex:numVertices">
	<c path="flash.Vector"><x path="Float"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromVector>
	</class>
	<class path="flash.display3D.textures.TextureBase" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/textures/TextureBase.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
	</class>
	<class path="flash.display3D.textures.CubeTexture" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/textures/CubeTexture.hx" extern="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadCompressedTextureFromByteArray public="1" set="method"><f a="data:byteArrayOffset:?async">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></uploadCompressedTextureFromByteArray>
		<uploadFromBitmapData public="1" set="method"><f a="source:side:?miplevel">
	<c path="flash.display.BitmapData"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></uploadFromBitmapData>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:side:?miplevel">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></uploadFromByteArray>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.textures.RectangleTexture" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/textures/RectangleTexture.hx" extern="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadFromBitmapData public="1" set="method"><f a="source">
	<c path="flash.display.BitmapData"/>
	<x path="Void"/>
</f></uploadFromBitmapData>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></uploadFromByteArray>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.textures.Texture" params="" file="C:\HaxeToolkit\haxe\std/flash/display3D/textures/Texture.hx" extern="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadCompressedTextureFromByteArray public="1" set="method"><f a="data:byteArrayOffset:?async">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></uploadCompressedTextureFromByteArray>
		<uploadFromBitmapData public="1" set="method"><f a="source:?miplevel">
	<c path="flash.display.BitmapData"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></uploadFromBitmapData>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:?miplevel">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></uploadFromByteArray>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.errors.Error" params="" file="C:\HaxeToolkit\haxe\std/flash/errors/Error.hx" extern="1">
		<length public="1" static="1"><x path="Int"/></length>
		<getErrorMessage public="1" set="method" static="1"><f a="index">
	<x path="Int"/>
	<c path="String"/>
</f></getErrorMessage>
		<throwError public="1" set="method" static="1"><f a="type:index:?p1:?p2:?p3:?p4:?p5">
	<x path="Class"><d/></x>
	<x path="UInt"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
</f></throwError>
		<errorID public="1" set="null"><x path="Int"/></errorID>
		<message public="1"><d/></message>
		<name public="1"><d/></name>
		<getStackTrace public="1" set="method"><f a=""><c path="String"/></f></getStackTrace>
		<new public="1" set="method"><f a="?message:?id">
	<d/>
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.events.Event" params="" file="C:\HaxeToolkit\haxe\std/flash/events/Event.hx" extern="1">
		<ACTIVATE public="1" static="1"><c path="String"/></ACTIVATE>
		<ADDED public="1" static="1"><c path="String"/></ADDED>
		<ADDED_TO_STAGE public="1" static="1"><c path="String"/></ADDED_TO_STAGE>
		<CANCEL public="1" static="1"><c path="String"/></CANCEL>
		<CHANGE public="1" static="1"><c path="String"/></CHANGE>
		<CHANNEL_MESSAGE public="1" static="1"><c path="String"/></CHANNEL_MESSAGE>
		<CHANNEL_STATE public="1" static="1"><c path="String"/></CHANNEL_STATE>
		<CLEAR public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CLEAR>
		<CLOSE public="1" static="1"><c path="String"/></CLOSE>
		<COMPLETE public="1" static="1"><c path="String"/></COMPLETE>
		<CONNECT public="1" static="1"><c path="String"/></CONNECT>
		<COPY public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</COPY>
		<CUT public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CUT>
		<DEACTIVATE public="1" static="1"><c path="String"/></DEACTIVATE>
		<ENTER_FRAME public="1" static="1"><c path="String"/></ENTER_FRAME>
		<EXIT_FRAME public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</EXIT_FRAME>
		<FRAME_CONSTRUCTED public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</FRAME_CONSTRUCTED>
		<FULLSCREEN public="1" static="1"><c path="String"/></FULLSCREEN>
		<ID3 public="1" static="1"><c path="String"/></ID3>
		<INIT public="1" static="1"><c path="String"/></INIT>
		<MOUSE_LEAVE public="1" static="1"><c path="String"/></MOUSE_LEAVE>
		<OPEN public="1" static="1"><c path="String"/></OPEN>
		<PASTE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</PASTE>
		<REMOVED public="1" static="1"><c path="String"/></REMOVED>
		<REMOVED_FROM_STAGE public="1" static="1"><c path="String"/></REMOVED_FROM_STAGE>
		<RENDER public="1" static="1"><c path="String"/></RENDER>
		<RESIZE public="1" static="1"><c path="String"/></RESIZE>
		<SCROLL public="1" static="1"><c path="String"/></SCROLL>
		<SELECT public="1" static="1"><c path="String"/></SELECT>
		<SELECT_ALL public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</SELECT_ALL>
		<SOUND_COMPLETE public="1" static="1"><c path="String"/></SOUND_COMPLETE>
		<TAB_CHILDREN_CHANGE public="1" static="1"><c path="String"/></TAB_CHILDREN_CHANGE>
		<TAB_ENABLED_CHANGE public="1" static="1"><c path="String"/></TAB_ENABLED_CHANGE>
		<TAB_INDEX_CHANGE public="1" static="1"><c path="String"/></TAB_INDEX_CHANGE>
		<UNLOAD public="1" static="1"><c path="String"/></UNLOAD>
		<VIDEO_FRAME public="1" static="1"><c path="String"/></VIDEO_FRAME>
		<WORKER_STATE public="1" static="1"><c path="String"/></WORKER_STATE>
		<bubbles public="1" set="null"><x path="Bool"/></bubbles>
		<cancelable public="1" set="null"><x path="Bool"/></cancelable>
		<currentTarget public="1" set="null"><d/></currentTarget>
		<eventPhase public="1" set="null"><e path="flash.events.EventPhase"/></eventPhase>
		<target public="1" set="null"><d/></target>
		<type public="1" set="null"><c path="String"/></type>
		<clone public="1" set="method"><f a=""><c path="flash.events.Event"/></f></clone>
		<formatToString public="1" set="method"><f a="className:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<c path="String"/>
</f></formatToString>
		<isDefaultPrevented public="1" set="method"><f a=""><x path="Bool"/></f></isDefaultPrevented>
		<preventDefault public="1" set="method"><f a=""><x path="Void"/></f></preventDefault>
		<stopImmediatePropagation public="1" set="method"><f a=""><x path="Void"/></f></stopImmediatePropagation>
		<stopPropagation public="1" set="method"><f a=""><x path="Void"/></f></stopPropagation>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.events.TextEvent" params="" file="C:\HaxeToolkit\haxe\std/flash/events/TextEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<LINK public="1" static="1"><c path="String"/></LINK>
		<TEXT_INPUT public="1" static="1"><c path="String"/></TEXT_INPUT>
		<text public="1"><c path="String"/></text>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?text">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.events.ErrorEvent" params="" file="C:\HaxeToolkit\haxe\std/flash/events/ErrorEvent.hx" extern="1">
		<extends path="flash.events.TextEvent"/>
		<ERROR public="1" static="1"><c path="String"/></ERROR>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?text:?id">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="flash.events.EventPhase" params="" file="C:\HaxeToolkit\haxe\std/flash/events/EventPhase.hx">
		<AT_TARGET/>
		<BUBBLING_PHASE/>
		<CAPTURING_PHASE/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>UInt</e></m>
		</meta>
	</enum>
	<class path="flash.events.IOErrorEvent" params="" file="C:\HaxeToolkit\haxe\std/flash/events/IOErrorEvent.hx" extern="1">
		<extends path="flash.events.ErrorEvent"/>
		<DISK_ERROR public="1" static="1"><c path="String"/></DISK_ERROR>
		<IO_ERROR public="1" static="1"><c path="String"/></IO_ERROR>
		<NETWORK_ERROR public="1" static="1"><c path="String"/></NETWORK_ERROR>
		<VERIFY_ERROR public="1" static="1"><c path="String"/></VERIFY_ERROR>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?text:?id">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.events.KeyboardEvent" params="" file="C:\HaxeToolkit\haxe\std/flash/events/KeyboardEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<KEY_DOWN public="1" static="1"><c path="String"/></KEY_DOWN>
		<KEY_UP public="1" static="1"><c path="String"/></KEY_UP>
		<altKey public="1"><x path="Bool"/></altKey>
		<charCode public="1"><x path="UInt"/></charCode>
		<ctrlKey public="1"><x path="Bool"/></ctrlKey>
		<keyCode public="1"><x path="UInt"/></keyCode>
		<keyLocation public="1"><e path="flash.ui.KeyLocation"/></keyLocation>
		<shiftKey public="1"><x path="Bool"/></shiftKey>
		<updateAfterEvent public="1" set="method"><f a=""><x path="Void"/></f></updateAfterEvent>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?charCodeValue:?keyCodeValue:?keyLocationValue:?ctrlKeyValue:?altKeyValue:?shiftKeyValue">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<e path="flash.ui.KeyLocation"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.events.ProgressEvent" params="" file="C:\HaxeToolkit\haxe\std/flash/events/ProgressEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<PROGRESS public="1" static="1"><c path="String"/></PROGRESS>
		<SOCKET_DATA public="1" static="1"><c path="String"/></SOCKET_DATA>
		<bytesLoaded public="1"><x path="Float"/></bytesLoaded>
		<bytesTotal public="1"><x path="Float"/></bytesTotal>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?bytesLoaded:?bytesTotal">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.events.SecurityErrorEvent" params="" file="C:\HaxeToolkit\haxe\std/flash/events/SecurityErrorEvent.hx" extern="1">
		<extends path="flash.events.ErrorEvent"/>
		<SECURITY_ERROR public="1" static="1"><c path="String"/></SECURITY_ERROR>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?text:?id">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.events.UncaughtErrorEvents" params="" file="C:\HaxeToolkit\haxe\std/flash/events/UncaughtErrorEvents.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<new public="1"><f a=""><x path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_1</e></m></meta>
	</class>
	<class path="flash.external.ExternalInterface" params="" file="C:\HaxeToolkit\haxe\std/flash/external/ExternalInterface.hx" extern="1">
		<available public="1" set="null" static="1"><x path="Bool"/></available>
		<marshallExceptions public="1" static="1"><x path="Bool"/></marshallExceptions>
		<objectID public="1" set="null" static="1"><c path="String"/></objectID>
		<addCallback public="1" set="method" static="1"><f a="functionName:closure">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></addCallback>
		<call public="1" set="method" static="1"><f a="functionName:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
</f></call>
	</class>
	<class path="flash.filters.BitmapFilter" params="" file="C:\HaxeToolkit\haxe\std/flash/filters/BitmapFilter.hx" extern="1">
		<clone public="1" set="method"><f a=""><c path="flash.filters.BitmapFilter"/></f></clone>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.geom.ColorTransform" params="" file="C:\HaxeToolkit\haxe\std/flash/geom/ColorTransform.hx" extern="1">
		<alphaMultiplier public="1"><x path="Float"/></alphaMultiplier>
		<alphaOffset public="1"><x path="Float"/></alphaOffset>
		<blueMultiplier public="1"><x path="Float"/></blueMultiplier>
		<blueOffset public="1"><x path="Float"/></blueOffset>
		<color public="1"><x path="UInt"/></color>
		<greenMultiplier public="1"><x path="Float"/></greenMultiplier>
		<greenOffset public="1"><x path="Float"/></greenOffset>
		<redMultiplier public="1"><x path="Float"/></redMultiplier>
		<redOffset public="1"><x path="Float"/></redOffset>
		<concat public="1" set="method"><f a="second">
	<c path="flash.geom.ColorTransform"/>
	<x path="Void"/>
</f></concat>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method"><f a="?redMultiplier:?greenMultiplier:?blueMultiplier:?alphaMultiplier:?redOffset:?greenOffset:?blueOffset:?alphaOffset">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Matrix" params="" file="C:\HaxeToolkit\haxe\std/flash/geom/Matrix.hx" extern="1">
		<a public="1"><x path="Float"/></a>
		<b public="1"><x path="Float"/></b>
		<c public="1"><x path="Float"/></c>
		<d public="1"><x path="Float"/></d>
		<tx public="1"><x path="Float"/></tx>
		<ty public="1"><x path="Float"/></ty>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Matrix"/></f></clone>
		<concat public="1" set="method"><f a="m">
	<c path="flash.geom.Matrix"/>
	<x path="Void"/>
</f></concat>
		<createBox public="1" set="method"><f a="scaleX:scaleY:?rotation:?tx:?ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></createBox>
		<createGradientBox public="1" set="method"><f a="width:height:?rotation:?tx:?ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></createGradientBox>
		<deltaTransformPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></deltaTransformPoint>
		<identity public="1" set="method"><f a=""><x path="Void"/></f></identity>
		<invert public="1" set="method"><f a=""><x path="Void"/></f></invert>
		<rotate public="1" set="method"><f a="angle">
	<x path="Float"/>
	<x path="Void"/>
</f></rotate>
		<scale public="1" set="method"><f a="sx:sy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scale>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<transformPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></transformPoint>
		<translate public="1" set="method"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></translate>
		<new public="1" set="method"><f a="?a:?b:?c:?d:?tx:?ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Matrix3D" params="" file="C:\HaxeToolkit\haxe\std/flash/geom/Matrix3D.hx" extern="1">
		<interpolate public="1" set="method" static="1"><f a="thisMat:toMat:percent">
	<c path="flash.geom.Matrix3D"/>
	<c path="flash.geom.Matrix3D"/>
	<x path="Float"/>
	<c path="flash.geom.Matrix3D"/>
</f></interpolate>
		<determinant public="1" set="null"><x path="Float"/></determinant>
		<position public="1"><c path="flash.geom.Vector3D"/></position>
		<rawData public="1"><c path="flash.Vector"><x path="Float"/></c></rawData>
		<append public="1" set="method"><f a="lhs">
	<c path="flash.geom.Matrix3D"/>
	<x path="Void"/>
</f></append>
		<appendRotation public="1" set="method"><f a="degrees:axis:?pivotPoint">
	<x path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></appendRotation>
		<appendScale public="1" set="method"><f a="xScale:yScale:zScale">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></appendScale>
		<appendTranslation public="1" set="method"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></appendTranslation>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Matrix3D"/></f></clone>
		<decompose public="1" set="method"><f a="?orientationStyle">
	<e path="flash.geom.Orientation3D"/>
	<c path="flash.Vector"><c path="flash.geom.Vector3D"/></c>
</f></decompose>
		<deltaTransformVector public="1" set="method"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></deltaTransformVector>
		<identity public="1" set="method"><f a=""><x path="Void"/></f></identity>
		<interpolateTo public="1" set="method"><f a="toMat:percent">
	<c path="flash.geom.Matrix3D"/>
	<x path="Float"/>
	<x path="Void"/>
</f></interpolateTo>
		<invert public="1" set="method"><f a=""><x path="Bool"/></f></invert>
		<pointAt public="1" set="method"><f a="pos:?at:?up">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></pointAt>
		<prepend public="1" set="method"><f a="rhs">
	<c path="flash.geom.Matrix3D"/>
	<x path="Void"/>
</f></prepend>
		<prependRotation public="1" set="method"><f a="degrees:axis:?pivotPoint">
	<x path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></prependRotation>
		<prependScale public="1" set="method"><f a="xScale:yScale:zScale">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependScale>
		<prependTranslation public="1" set="method"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependTranslation>
		<recompose public="1" set="method"><f a="components:?orientationStyle">
	<c path="flash.Vector"><c path="flash.geom.Vector3D"/></c>
	<e path="flash.geom.Orientation3D"/>
	<x path="Bool"/>
</f></recompose>
		<transformVector public="1" set="method"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></transformVector>
		<transformVectors public="1" set="method"><f a="vin:vout">
	<c path="flash.Vector"><x path="Float"/></c>
	<c path="flash.Vector"><x path="Float"/></c>
	<x path="Void"/>
</f></transformVectors>
		<transpose public="1" set="method"><f a=""><x path="Void"/></f></transpose>
		<new public="1" set="method"><f a="?v">
	<c path="flash.Vector"><x path="Float"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<enum path="flash.geom.Orientation3D" params="" file="C:\HaxeToolkit\haxe\std/flash/geom/Orientation3D.hx">
		<AXIS_ANGLE/>
		<EULER_ANGLES/>
		<QUATERNION/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.geom.PerspectiveProjection" params="" file="C:\HaxeToolkit\haxe\std/flash/geom/PerspectiveProjection.hx" extern="1">
		<fieldOfView public="1"><x path="Float"/></fieldOfView>
		<focalLength public="1"><x path="Float"/></focalLength>
		<projectionCenter public="1"><c path="flash.geom.Point"/></projectionCenter>
		<toMatrix3D public="1" set="method"><f a=""><c path="flash.geom.Matrix3D"/></f></toMatrix3D>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.geom.Point" params="" file="C:\HaxeToolkit\haxe\std/flash/geom/Point.hx" extern="1">
		<distance public="1" set="method" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<x path="Float"/>
</f></distance>
		<interpolate public="1" set="method" static="1"><f a="pt1:pt2:f">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<x path="Float"/>
	<c path="flash.geom.Point"/>
</f></interpolate>
		<polar public="1" set="method" static="1"><f a="len:angle">
	<x path="Float"/>
	<x path="Float"/>
	<c path="flash.geom.Point"/>
</f></polar>
		<length public="1" set="null"><x path="Float"/></length>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<add public="1" set="method"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></add>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Point"/></f></clone>
		<equals public="1" set="method"><f a="toCompare">
	<c path="flash.geom.Point"/>
	<x path="Bool"/>
</f></equals>
		<normalize public="1" set="method"><f a="thickness">
	<x path="Float"/>
	<x path="Void"/>
</f></normalize>
		<offset public="1" set="method"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></offset>
		<subtract public="1" set="method"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></subtract>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method"><f a="?x:?y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Rectangle" params="" file="C:\HaxeToolkit\haxe\std/flash/geom/Rectangle.hx" extern="1">
		<bottom public="1"><x path="Float"/></bottom>
		<bottomRight public="1"><c path="flash.geom.Point"/></bottomRight>
		<height public="1"><x path="Float"/></height>
		<left public="1"><x path="Float"/></left>
		<right public="1"><x path="Float"/></right>
		<size public="1"><c path="flash.geom.Point"/></size>
		<top public="1"><x path="Float"/></top>
		<topLeft public="1"><c path="flash.geom.Point"/></topLeft>
		<width public="1"><x path="Float"/></width>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Rectangle"/></f></clone>
		<contains public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></contains>
		<containsPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<x path="Bool"/>
</f></containsPoint>
		<containsRect public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
</f></containsRect>
		<equals public="1" set="method"><f a="toCompare">
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
</f></equals>
		<inflate public="1" set="method"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></inflate>
		<inflatePoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<x path="Void"/>
</f></inflatePoint>
		<intersection public="1" set="method"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></intersection>
		<intersects public="1" set="method"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
</f></intersects>
		<isEmpty public="1" set="method"><f a=""><x path="Bool"/></f></isEmpty>
		<offset public="1" set="method"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></offset>
		<offsetPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<x path="Void"/>
</f></offsetPoint>
		<setEmpty public="1" set="method"><f a=""><x path="Void"/></f></setEmpty>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<union public="1" set="method"><f a="toUnion">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></union>
		<new public="1" set="method"><f a="?x:?y:?width:?height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Transform" params="" file="C:\HaxeToolkit\haxe\std/flash/geom/Transform.hx" extern="1">
		<colorTransform public="1"><c path="flash.geom.ColorTransform"/></colorTransform>
		<concatenatedColorTransform public="1" set="null"><c path="flash.geom.ColorTransform"/></concatenatedColorTransform>
		<concatenatedMatrix public="1" set="null"><c path="flash.geom.Matrix"/></concatenatedMatrix>
		<matrix public="1"><c path="flash.geom.Matrix"/></matrix>
		<matrix3D public="1">
			<c path="flash.geom.Matrix3D"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</matrix3D>
		<perspectiveProjection public="1">
			<c path="flash.geom.PerspectiveProjection"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</perspectiveProjection>
		<pixelBounds public="1" set="null"><c path="flash.geom.Rectangle"/></pixelBounds>
		<getRelativeMatrix3D public="1" set="method">
			<f a="relativeTo">
				<c path="flash.display.DisplayObject"/>
				<c path="flash.geom.Matrix3D"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</getRelativeMatrix3D>
		<new public="1" set="method"><f a="displayObject">
	<c path="flash.display.DisplayObject"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Vector3D" params="" file="C:\HaxeToolkit\haxe\std/flash/geom/Vector3D.hx" extern="1">
		<X_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></X_AXIS>
		<Y_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></Y_AXIS>
		<Z_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></Z_AXIS>
		<angleBetween public="1" set="method" static="1"><f a="a:b">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Float"/>
</f></angleBetween>
		<distance public="1" set="method" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Float"/>
</f></distance>
		<length public="1" set="null"><x path="Float"/></length>
		<lengthSquared public="1" set="null"><x path="Float"/></lengthSquared>
		<w public="1"><x path="Float"/></w>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<add public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></add>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Vector3D"/></f></clone>
		<crossProduct public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></crossProduct>
		<decrementBy public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></decrementBy>
		<dotProduct public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<x path="Float"/>
</f></dotProduct>
		<equals public="1" set="method"><f a="toCompare:?allFour">
	<c path="flash.geom.Vector3D"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></equals>
		<incrementBy public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></incrementBy>
		<nearEquals public="1" set="method"><f a="toCompare:tolerance:?allFour">
	<c path="flash.geom.Vector3D"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></nearEquals>
		<negate public="1" set="method"><f a=""><x path="Void"/></f></negate>
		<normalize public="1" set="method"><f a=""><x path="Float"/></f></normalize>
		<project public="1" set="method"><f a=""><x path="Void"/></f></project>
		<scaleBy public="1" set="method"><f a="s">
	<x path="Float"/>
	<x path="Void"/>
</f></scaleBy>
		<subtract public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></subtract>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method"><f a="?x:?y:?z:?w">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.media.AVCaptionStyle" params="" file="C:\HaxeToolkit\haxe\std/flash/media/AVCaptionStyle.hx" extern="1">
		<BLACK public="1" static="1"><c path="String"/></BLACK>
		<BLUE public="1" static="1"><c path="String"/></BLUE>
		<BRIGHT_BLUE public="1" static="1"><c path="String"/></BRIGHT_BLUE>
		<BRIGHT_CYAN public="1" static="1"><c path="String"/></BRIGHT_CYAN>
		<BRIGHT_GREEN public="1" static="1"><c path="String"/></BRIGHT_GREEN>
		<BRIGHT_MAGENTA public="1" static="1"><c path="String"/></BRIGHT_MAGENTA>
		<BRIGHT_RED public="1" static="1"><c path="String"/></BRIGHT_RED>
		<BRIGHT_WHITE public="1" static="1"><c path="String"/></BRIGHT_WHITE>
		<BRIGHT_YELLOW public="1" static="1"><c path="String"/></BRIGHT_YELLOW>
		<CASUAL public="1" static="1"><c path="String"/></CASUAL>
		<CURSIVE public="1" static="1"><c path="String"/></CURSIVE>
		<CYAN public="1" static="1"><c path="String"/></CYAN>
		<DARK_BLUE public="1" static="1"><c path="String"/></DARK_BLUE>
		<DARK_CYAN public="1" static="1"><c path="String"/></DARK_CYAN>
		<DARK_GREEN public="1" static="1"><c path="String"/></DARK_GREEN>
		<DARK_MAGENTA public="1" static="1"><c path="String"/></DARK_MAGENTA>
		<DARK_RED public="1" static="1"><c path="String"/></DARK_RED>
		<DARK_YELLOW public="1" static="1"><c path="String"/></DARK_YELLOW>
		<DEFAULT public="1" static="1"><c path="String"/></DEFAULT>
		<DEPRESSED public="1" static="1"><c path="String"/></DEPRESSED>
		<GRAY public="1" static="1"><c path="String"/></GRAY>
		<GREEN public="1" static="1"><c path="String"/></GREEN>
		<LARGE public="1" static="1"><c path="String"/></LARGE>
		<LEFT_DROP_SHADOW public="1" static="1"><c path="String"/></LEFT_DROP_SHADOW>
		<MAGENTA public="1" static="1"><c path="String"/></MAGENTA>
		<MEDIUM public="1" static="1"><c path="String"/></MEDIUM>
		<MONOSPACED_WITHOUT_SERIFS public="1" static="1"><c path="String"/></MONOSPACED_WITHOUT_SERIFS>
		<MONOSPACE_WITH_SERIFS public="1" static="1"><c path="String"/></MONOSPACE_WITH_SERIFS>
		<NONE public="1" static="1"><c path="String"/></NONE>
		<PROPORTIONAL_WITHOUT_SERIFS public="1" static="1"><c path="String"/></PROPORTIONAL_WITHOUT_SERIFS>
		<PROPORTIONAL_WITH_SERIFS public="1" static="1"><c path="String"/></PROPORTIONAL_WITH_SERIFS>
		<RAISED public="1" static="1"><c path="String"/></RAISED>
		<RED public="1" static="1"><c path="String"/></RED>
		<RIGHT_DROP_SHADOW public="1" static="1"><c path="String"/></RIGHT_DROP_SHADOW>
		<SMALL public="1" static="1"><c path="String"/></SMALL>
		<SMALL_CAPITALS public="1" static="1"><c path="String"/></SMALL_CAPITALS>
		<UNIFORM public="1" static="1"><c path="String"/></UNIFORM>
		<WHITE public="1" static="1"><c path="String"/></WHITE>
		<YELLOW public="1" static="1"><c path="String"/></YELLOW>
		<backgroundColor public="1"><c path="String"/></backgroundColor>
		<backgroundOpacity public="1"><c path="String"/></backgroundOpacity>
		<edgeColor public="1"><c path="String"/></edgeColor>
		<fillColor public="1"><c path="String"/></fillColor>
		<fillOpacity public="1"><c path="String"/></fillOpacity>
		<font public="1"><c path="String"/></font>
		<fontColor public="1"><c path="String"/></fontColor>
		<fontEdge public="1"><c path="String"/></fontEdge>
		<fontOpacity public="1"><c path="String"/></fontOpacity>
		<size public="1"><c path="String"/></size>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.media.AVPlayState" params="" file="C:\HaxeToolkit\haxe\std/flash/media/AVPlayState.hx" extern="1">
		<BUFFERING public="1" static="1"><x path="Int"/></BUFFERING>
		<EOF public="1" static="1"><x path="Int"/></EOF>
		<PAUSED public="1" static="1"><x path="Int"/></PAUSED>
		<PLAYING public="1" static="1"><x path="Int"/></PLAYING>
		<READY public="1" static="1"><x path="Int"/></READY>
		<SUSPENDED public="1" static="1"><x path="Int"/></SUSPENDED>
		<TRICK_PLAY public="1" static="1"><x path="Int"/></TRICK_PLAY>
		<UNINITIALIZED public="1" static="1"><x path="Int"/></UNINITIALIZED>
		<UNRECOVERABLE_ERROR public="1" static="1"><x path="Int"/></UNRECOVERABLE_ERROR>
		<state public="1" set="null"><x path="Int"/></state>
		<new public="1" set="method"><f a="state">
	<x path="UInt"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.media.AVResult" params="" file="C:\HaxeToolkit\haxe\std/flash/media/AVResult.hx" extern="1">
		<ASYNC_OPERATION_IN_PROGRESS public="1" static="1"><x path="Int"/></ASYNC_OPERATION_IN_PROGRESS>
		<AUDIO_START_ERROR public="1" static="1"><x path="Int"/></AUDIO_START_ERROR>
		<BAD_MANIFEST_SIGNATURE public="1" static="1"><x path="Int"/></BAD_MANIFEST_SIGNATURE>
		<BAD_MEDIASAMPLE_FOUND public="1" static="1"><x path="Int"/></BAD_MEDIASAMPLE_FOUND>
		<BAD_MEDIA_INTERLEAVING public="1" static="1"><x path="Int"/></BAD_MEDIA_INTERLEAVING>
		<CALLED_FROM_WRONG_THREAD public="1" static="1"><x path="Int"/></CALLED_FROM_WRONG_THREAD>
		<CANNOT_ERASE_TIMELINE public="1" static="1"><x path="Int"/></CANNOT_ERASE_TIMELINE>
		<CANNOT_FAIL_OVER public="1" static="1"><x path="Int"/></CANNOT_FAIL_OVER>
		<CANNOT_LOAD_PLAY_LIST public="1" static="1"><x path="Int"/></CANNOT_LOAD_PLAY_LIST>
		<CANNOT_SPLIT_TIMELINE public="1" static="1"><x path="Int"/></CANNOT_SPLIT_TIMELINE>
		<CODEC_NOT_SUPPORTED public="1" static="1"><x path="Int"/></CODEC_NOT_SUPPORTED>
		<COMPONENT_CREATION_FAILURE public="1" static="1"><x path="Int"/></COMPONENT_CREATION_FAILURE>
		<CONTAINER_NOT_SUPPORTED public="1" static="1"><x path="Int"/></CONTAINER_NOT_SUPPORTED>
		<CONTENT_LENGTH_MISMATCH public="1" static="1"><x path="Int"/></CONTENT_LENGTH_MISMATCH>
		<CURRENT_PERIOD_EXPIRED public="1" static="1"><x path="Int"/></CURRENT_PERIOD_EXPIRED>
		<DECODER_FAILED public="1" static="1"><x path="Int"/></DECODER_FAILED>
		<DEVICE_OPEN_ERROR public="1" static="1"><x path="Int"/></DEVICE_OPEN_ERROR>
		<DID_NOT_GET_NEXT_FRAGMENT public="1" static="1"><x path="Int"/></DID_NOT_GET_NEXT_FRAGMENT>
		<DRM_INIT_ERROR public="1" static="1"><x path="Int"/></DRM_INIT_ERROR>
		<DRM_NOT_AVAILABLE public="1" static="1"><x path="Int"/></DRM_NOT_AVAILABLE>
		<END_OF_PERIOD public="1" static="1"><x path="Int"/></END_OF_PERIOD>
		<EOF public="1" static="1"><x path="Int"/></EOF>
		<FILE_NOT_FOUND public="1" static="1"><x path="Int"/></FILE_NOT_FOUND>
		<FILE_OPEN_ERROR public="1" static="1"><x path="Int"/></FILE_OPEN_ERROR>
		<FILE_READ_ERROR public="1" static="1"><x path="Int"/></FILE_READ_ERROR>
		<FILE_STRUCTURE_INVALID public="1" static="1"><x path="Int"/></FILE_STRUCTURE_INVALID>
		<FILE_WRITE_ERROR public="1" static="1"><x path="Int"/></FILE_WRITE_ERROR>
		<FRAGMENT_READ_ERROR public="1" static="1"><x path="Int"/></FRAGMENT_READ_ERROR>
		<GENERIC_ERROR public="1" static="1"><x path="Int"/></GENERIC_ERROR>
		<HTTP_TIME_OUT public="1" static="1"><x path="Int"/></HTTP_TIME_OUT>
		<INCOMPATIBLE_RENDER_MODE public="1" static="1"><x path="Int"/></INCOMPATIBLE_RENDER_MODE>
		<INCOMPATIBLE_VERSION public="1" static="1"><x path="Int"/></INCOMPATIBLE_VERSION>
		<INTERNAL_ERROR public="1" static="1"><x path="Int"/></INTERNAL_ERROR>
		<INVALID_OPERATION public="1" static="1"><x path="Int"/></INVALID_OPERATION>
		<INVALID_PARAMETER public="1" static="1"><x path="Int"/></INVALID_PARAMETER>
		<INVALID_REPLACE_DURATION public="1" static="1"><x path="Int"/></INVALID_REPLACE_DURATION>
		<INVALID_SEEK_TIME public="1" static="1"><x path="Int"/></INVALID_SEEK_TIME>
		<INVALID_WITH_AUDIO_ONLY_FILE public="1" static="1"><x path="Int"/></INVALID_WITH_AUDIO_ONLY_FILE>
		<IRRECOVERABLE_ERROR public="1" static="1"><x path="Int"/></IRRECOVERABLE_ERROR>
		<LISTENER_NOT_FOUND public="1" static="1"><x path="Int"/></LISTENER_NOT_FOUND>
		<LIVE_HOLD public="1" static="1"><x path="Int"/></LIVE_HOLD>
		<LIVE_WINDOW_MOVED_BACKWARD public="1" static="1"><x path="Int"/></LIVE_WINDOW_MOVED_BACKWARD>
		<LOST_CONNECTION_RECOVERABLE public="1" static="1"><x path="Int"/></LOST_CONNECTION_RECOVERABLE>
		<MANIFEST_FILE_UNEXPECTEDLY_CHANGED public="1" static="1"><x path="Int"/></MANIFEST_FILE_UNEXPECTEDLY_CHANGED>
		<NETWORK_DOWN public="1" static="1"><x path="Int"/></NETWORK_DOWN>
		<NETWORK_ERROR public="1" static="1"><x path="Int"/></NETWORK_ERROR>
		<NETWORK_UNAVAILABLE public="1" static="1"><x path="Int"/></NETWORK_UNAVAILABLE>
		<NOT_IMPLEMENTED public="1" static="1"><x path="Int"/></NOT_IMPLEMENTED>
		<NO_AUDIO_SINK public="1" static="1"><x path="Int"/></NO_AUDIO_SINK>
		<NO_FIXED_SIZE public="1" static="1"><x path="Int"/></NO_FIXED_SIZE>
		<NO_TIMELINE public="1" static="1"><x path="Int"/></NO_TIMELINE>
		<NO_USEABLE_BITRATE_PROFILE public="1" static="1"><x path="Int"/></NO_USEABLE_BITRATE_PROFILE>
		<NULL_OPERATION public="1" static="1"><x path="Int"/></NULL_OPERATION>
		<ONLY_ALLOWED_IN_PAUSED_STATE public="1" static="1"><x path="Int"/></ONLY_ALLOWED_IN_PAUSED_STATE>
		<OPERATION_ABORTED public="1" static="1"><x path="Int"/></OPERATION_ABORTED>
		<OUT_OF_MEMORY public="1" static="1"><x path="Int"/></OUT_OF_MEMORY>
		<OVERFLOW public="1" static="1"><x path="Int"/></OVERFLOW>
		<PARSE_ERROR public="1" static="1"><x path="Int"/></PARSE_ERROR>
		<PARTIAL_REPLACEMENT public="1" static="1"><x path="Int"/></PARTIAL_REPLACEMENT>
		<PERIOD_HOLD public="1" static="1"><x path="Int"/></PERIOD_HOLD>
		<PERIOD_NOT_LOADED public="1" static="1"><x path="Int"/></PERIOD_NOT_LOADED>
		<PLAYBACK_NOT_ENABLED public="1" static="1"><x path="Int"/></PLAYBACK_NOT_ENABLED>
		<POSTROLL_WITH_LIVE_NOT_ALLOWED public="1" static="1"><x path="Int"/></POSTROLL_WITH_LIVE_NOT_ALLOWED>
		<PREVIOUS_STEP_SEEK_IN_PROGRESS public="1" static="1"><x path="Int"/></PREVIOUS_STEP_SEEK_IN_PROGRESS>
		<PROTOCOL_NOT_SUPPORTED public="1" static="1"><x path="Int"/></PROTOCOL_NOT_SUPPORTED>
		<RANGE_ERROR public="1" static="1"><x path="Int"/></RANGE_ERROR>
		<RANGE_SPANS_READHEAD public="1" static="1"><x path="Int"/></RANGE_SPANS_READHEAD>
		<RENDITION_M3U8_ERROR public="1" static="1"><x path="Int"/></RENDITION_M3U8_ERROR>
		<REPLACEMENT_FAILED public="1" static="1"><x path="Int"/></REPLACEMENT_FAILED>
		<RESOURCE_NOT_SPECIFIED public="1" static="1"><x path="Int"/></RESOURCE_NOT_SPECIFIED>
		<SEEK_FAILED public="1" static="1"><x path="Int"/></SEEK_FAILED>
		<SEGMENT_SKIPPED_ON_FAILURE public="1" static="1"><x path="Int"/></SEGMENT_SKIPPED_ON_FAILURE>
		<SIZE_UNKNOWN public="1" static="1"><x path="Int"/></SIZE_UNKNOWN>
		<SPS_PPS_FOUND_OUTSIDE_AVCC public="1" static="1"><x path="Int"/></SPS_PPS_FOUND_OUTSIDE_AVCC>
		<SUCCESS public="1" static="1"><x path="Int"/></SUCCESS>
		<SWITCH_TO_ASYMMETRIC_PROFILE public="1" static="1"><x path="Int"/></SWITCH_TO_ASYMMETRIC_PROFILE>
		<UNDERFLOW public="1" static="1"><x path="Int"/></UNDERFLOW>
		<UNSUPPORTED_CONFIGURATION public="1" static="1"><x path="Int"/></UNSUPPORTED_CONFIGURATION>
		<UNSUPPORTED_HLS_VERSION public="1" static="1"><x path="Int"/></UNSUPPORTED_HLS_VERSION>
		<UNSUPPORTED_OPERATION public="1" static="1"><x path="Int"/></UNSUPPORTED_OPERATION>
		<VIDEO_PROFILE_NOT_SUPPORTED public="1" static="1"><x path="Int"/></VIDEO_PROFILE_NOT_SUPPORTED>
		<WAITING_FOR_INIT public="1" static="1"><x path="Int"/></WAITING_FOR_INIT>
		<result public="1" set="null"><x path="Int"/></result>
		<new public="1" set="method"><f a="inResult">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.media.AVSource" params="" file="C:\HaxeToolkit\haxe\std/flash/media/AVSource.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.media.AVStream" params="" file="C:\HaxeToolkit\haxe\std/flash/media/AVStream.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<HARDWARE public="1" static="1"><c path="String"/></HARDWARE>
		<SOFTWARE public="1" static="1"><c path="String"/></SOFTWARE>
		<UNDEFINED public="1" static="1"><c path="String"/></UNDEFINED>
		<backBufferLength public="1" set="null"><x path="Float"/></backBufferLength>
		<backBufferTime public="1" get="null"><x path="Float"/></backBufferTime>
		<bufferLength public="1" set="null"><x path="Float"/></bufferLength>
		<bufferTime public="1" get="null"><x path="Float"/></bufferTime>
		<captionStyle public="1" get="null"><c path="flash.media.AVCaptionStyle"/></captionStyle>
		<captionsEnabled public="1"><x path="Bool"/></captionsEnabled>
		<currentFPS public="1" set="null"><x path="Float"/></currentFPS>
		<decoderType public="1" set="null"><c path="String"/></decoderType>
		<droppedFrames public="1" set="null"><x path="Int"/></droppedFrames>
		<frameTime public="1" set="null"><x path="Float"/></frameTime>
		<initialBufferTime public="1" get="null"><x path="Float"/></initialBufferTime>
		<playState public="1" set="null"><c path="flash.media.AVPlayState"/></playState>
		<renderType public="1" set="null"><c path="String"/></renderType>
		<time public="1" set="null"><x path="Float"/></time>
		<useHardwareDecoder public="1"><x path="Bool"/></useHardwareDecoder>
		<volume public="1"><x path="Float"/></volume>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<fastForward public="1" set="method"><f a="rate">
	<x path="Float"/>
	<c path="flash.media.AVResult"/>
</f></fastForward>
		<pause public="1" set="method"><f a=""><c path="flash.media.AVResult"/></f></pause>
		<play public="1" set="method"><f a=""><c path="flash.media.AVResult"/></f></play>
		<resume public="1" set="method"><f a=""><x path="Bool"/></f></resume>
		<rewind public="1" set="method"><f a="rate">
	<x path="Float"/>
	<c path="flash.media.AVResult"/>
</f></rewind>
		<seek public="1" set="method"><f a="offset:?inBufferSeek">
	<x path="Float"/>
	<x path="Bool"/>
	<c path="flash.media.AVResult"/>
</f></seek>
		<seekToLivePoint public="1" set="method"><f a=""><c path="flash.media.AVResult"/></f></seekToLivePoint>
		<seekToLocalTime public="1" set="method"><f a="periodIndex:time">
	<x path="Int"/>
	<x path="Float"/>
	<c path="flash.media.AVResult"/>
</f></seekToLocalTime>
		<setPlaySpeed public="1" set="method"><f a="speed:reserved">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setPlaySpeed>
		<step public="1" set="method"><f a="frames">
	<x path="Int"/>
	<c path="flash.media.AVResult"/>
</f></step>
		<new public="1" set="method"><f a="source">
	<c path="flash.media.AVSource"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.media.Camera" params="" file="C:\HaxeToolkit\haxe\std/flash/media/Camera.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<names public="1" set="null" static="1"><c path="Array"><d/></c></names>
		<getCamera public="1" set="method" static="1"><f a="?name">
	<c path="String"/>
	<c path="flash.media.Camera"/>
</f></getCamera>
		<activityLevel public="1" set="null"><x path="Float"/></activityLevel>
		<bandwidth public="1" set="null"><x path="Int"/></bandwidth>
		<currentFPS public="1" set="null"><x path="Float"/></currentFPS>
		<fps public="1" set="null"><x path="Float"/></fps>
		<height public="1" set="null"><x path="Int"/></height>
		<index public="1" set="null"><x path="Int"/></index>
		<keyFrameInterval public="1" set="null"><x path="Int"/></keyFrameInterval>
		<loopback public="1" set="null"><x path="Bool"/></loopback>
		<motionLevel public="1" set="null"><x path="Int"/></motionLevel>
		<motionTimeout public="1" set="null"><x path="Int"/></motionTimeout>
		<muted public="1" set="null"><x path="Bool"/></muted>
		<name public="1" set="null"><c path="String"/></name>
		<quality public="1" set="null"><x path="Int"/></quality>
		<width public="1" set="null"><x path="Int"/></width>
		<setCursor public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></setCursor>
		<setKeyFrameInterval public="1" set="method"><f a="keyFrameInterval">
	<x path="Int"/>
	<x path="Void"/>
</f></setKeyFrameInterval>
		<setLoopback public="1" set="method"><f a="?compress">
	<x path="Bool"/>
	<x path="Void"/>
</f></setLoopback>
		<setMode public="1" set="method"><f a="width:height:fps:?favorArea">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setMode>
		<setMotionLevel public="1" set="method"><f a="motionLevel:?timeout">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setMotionLevel>
		<setQuality public="1" set="method"><f a="bandwidth:quality">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setQuality>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.media.Microphone" params="" file="C:\HaxeToolkit\haxe\std/flash/media/Microphone.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<names public="1" set="null" static="1"><c path="Array"><d/></c></names>
		<getMicrophone public="1" set="method" static="1"><f a="?index">
	<x path="Int"/>
	<c path="flash.media.Microphone"/>
</f></getMicrophone>
		<activityLevel public="1" set="null"><x path="Float"/></activityLevel>
		<codec public="1">
			<e path="flash.media.SoundCodec"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</codec>
		<encodeQuality public="1">
			<x path="Int"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</encodeQuality>
		<framesPerPacket public="1">
			<x path="Int"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</framesPerPacket>
		<gain public="1"><x path="Float"/></gain>
		<index public="1" set="null"><x path="Int"/></index>
		<muted public="1" set="null"><x path="Bool"/></muted>
		<name public="1" set="null"><c path="String"/></name>
		<rate public="1"><x path="Int"/></rate>
		<silenceLevel public="1" set="null"><x path="Float"/></silenceLevel>
		<silenceTimeout public="1" set="null"><x path="Int"/></silenceTimeout>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<useEchoSuppression public="1" set="null"><x path="Bool"/></useEchoSuppression>
		<setLoopBack public="1" set="method"><f a="?state">
	<x path="Bool"/>
	<x path="Void"/>
</f></setLoopBack>
		<setSilenceLevel public="1" set="method"><f a="silenceLevel:?timeout">
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setSilenceLevel>
		<setUseEchoSuppression public="1" set="method"><f a="useEchoSuppression">
	<x path="Bool"/>
	<x path="Void"/>
</f></setUseEchoSuppression>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.media.MicrophoneEnhancedMode" params="" file="C:\HaxeToolkit\haxe\std/flash/media/MicrophoneEnhancedMode.hx">
		<FULL_DUPLEX/>
		<HALF_DUPLEX/>
		<HEADSET/>
		<OFF/>
		<SPEAKER_MUTE/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_2</e></m>
		</meta>
	</enum>
	<class path="flash.media.MicrophoneEnhancedOptions" params="" file="C:\HaxeToolkit\haxe\std/flash/media/MicrophoneEnhancedOptions.hx" extern="1">
		<autoGain public="1"><x path="Bool"/></autoGain>
		<echoPath public="1"><x path="Int"/></echoPath>
		<isVoiceDetected public="1"><x path="Int"/></isVoiceDetected>
		<mode public="1"><e path="flash.media.MicrophoneEnhancedMode"/></mode>
		<nonLinearProcessing public="1"><x path="Bool"/></nonLinearProcessing>
		<new public="1"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":final"/>
			<m n=":require"><e>flash10_2</e></m>
		</meta>
	</class>
	<enum path="flash.media.SoundCodec" params="" file="C:\HaxeToolkit\haxe\std/flash/media/SoundCodec.hx">
		<NELLYMOSER/>
		<PCMA/>
		<PCMU/>
		<SPEEX/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.media.SoundTransform" params="" file="C:\HaxeToolkit\haxe\std/flash/media/SoundTransform.hx" extern="1">
		<leftToLeft public="1"><x path="Float"/></leftToLeft>
		<leftToRight public="1"><x path="Float"/></leftToRight>
		<pan public="1"><x path="Float"/></pan>
		<rightToLeft public="1"><x path="Float"/></rightToLeft>
		<rightToRight public="1"><x path="Float"/></rightToRight>
		<volume public="1"><x path="Float"/></volume>
		<new public="1" set="method"><f a="?vol:?panning">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.media.StageVideo" params="" file="C:\HaxeToolkit\haxe\std/flash/media/StageVideo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<colorSpaces public="1" set="null"><c path="flash.Vector"><c path="String"/></c></colorSpaces>
		<depth public="1"><x path="Int"/></depth>
		<pan public="1"><c path="flash.geom.Point"/></pan>
		<videoHeight public="1" set="null"><x path="Int"/></videoHeight>
		<videoWidth public="1" set="null"><x path="Int"/></videoWidth>
		<viewPort public="1"><c path="flash.geom.Rectangle"/></viewPort>
		<zoom public="1"><c path="flash.geom.Point"/></zoom>
		<attachNetStream public="1" set="method"><f a="netStream">
	<c path="flash.net.NetStream"/>
	<x path="Void"/>
</f></attachNetStream>
		<new public="1"><f a=""><x path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_2</e></m></meta>
	</class>
	<class path="flash.media.VideoStreamSettings" params="" file="C:\HaxeToolkit\haxe\std/flash/media/VideoStreamSettings.hx" extern="1">
		<bandwidth public="1" set="null"><x path="Int"/></bandwidth>
		<codec public="1" set="null"><c path="String"/></codec>
		<fps public="1" set="null"><x path="Float"/></fps>
		<height public="1" set="null"><x path="Int"/></height>
		<keyFrameInterval public="1" set="null"><x path="Int"/></keyFrameInterval>
		<quality public="1" set="null"><x path="Int"/></quality>
		<width public="1" set="null"><x path="Int"/></width>
		<setKeyFrameInterval public="1" set="method"><f a="keyFrameInterval">
	<x path="Int"/>
	<x path="Void"/>
</f></setKeyFrameInterval>
		<setMode public="1" set="method"><f a="width:height:fps">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setMode>
		<setQuality public="1" set="method"><f a="bandwidth:quality">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setQuality>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.net.NetConnection" params="" file="C:\HaxeToolkit\haxe\std/flash/net/NetConnection.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<defaultObjectEncoding public="1" static="1"><x path="UInt"/></defaultObjectEncoding>
		<client public="1"><d/></client>
		<connected public="1" set="null"><x path="Bool"/></connected>
		<connectedProxyType public="1" set="null"><c path="String"/></connectedProxyType>
		<farID public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farID>
		<farNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farNonce>
		<maxPeerConnections public="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</maxPeerConnections>
		<nearID public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</nearID>
		<nearNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</nearNonce>
		<objectEncoding public="1"><x path="UInt"/></objectEncoding>
		<protocol public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</protocol>
		<proxyType public="1"><c path="String"/></proxyType>
		<unconnectedPeerStreams public="1" set="null">
			<c path="Array"><d/></c>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</unconnectedPeerStreams>
		<uri public="1" set="null"><c path="String"/></uri>
		<usingTLS public="1" set="null"><x path="Bool"/></usingTLS>
		<addHeader public="1" set="method"><f a="operation:?mustUnderstand:?param">
	<c path="String"/>
	<x path="Bool"/>
	<t path="flash.utils.Object"/>
	<x path="Void"/>
</f></addHeader>
		<call public="1" set="method"><f a="command:responder:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<c path="flash.net.Responder"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></call>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<connect public="1" set="method"><f a="command:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></connect>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.net.NetStream" params="" file="C:\HaxeToolkit\haxe\std/flash/net/NetStream.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<CONNECT_TO_FMS public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CONNECT_TO_FMS>
		<DIRECT_CONNECTIONS public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</DIRECT_CONNECTIONS>
		<resetDRMVouchers public="1" set="method" static="1"><f a=""><x path="Void"/></f></resetDRMVouchers>
		<audioCodec public="1" set="null"><x path="UInt"/></audioCodec>
		<bufferLength public="1" set="null"><x path="Float"/></bufferLength>
		<bufferTime public="1"><x path="Float"/></bufferTime>
		<bytesLoaded public="1" set="null"><x path="UInt"/></bytesLoaded>
		<bytesTotal public="1" set="null"><x path="UInt"/></bytesTotal>
		<checkPolicyFile public="1"><x path="Bool"/></checkPolicyFile>
		<client public="1"><d/></client>
		<currentFPS public="1" set="null"><x path="Float"/></currentFPS>
		<decodedFrames public="1" set="null"><x path="UInt"/></decodedFrames>
		<farID public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farID>
		<farNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farNonce>
		<info public="1" set="null">
			<c path="flash.net.NetStreamInfo"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</info>
		<liveDelay public="1" set="null"><x path="Float"/></liveDelay>
		<maxPauseBufferTime public="1">
			<x path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</maxPauseBufferTime>
		<nearNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</nearNonce>
		<objectEncoding public="1" set="null"><x path="UInt"/></objectEncoding>
		<peerStreams public="1" set="null">
			<c path="Array"><d/></c>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</peerStreams>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<time public="1" set="null"><x path="Float"/></time>
		<videoCodec public="1" set="null"><x path="UInt"/></videoCodec>
		<attachAudio public="1" set="method"><f a="microphone">
	<c path="flash.media.Microphone"/>
	<x path="Void"/>
</f></attachAudio>
		<attachCamera public="1" set="method"><f a="theCamera:?snapshotMilliseconds">
	<c path="flash.media.Camera"/>
	<x path="Int"/>
	<x path="Void"/>
</f></attachCamera>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<onPeerConnect public="1" set="method">
			<f a="subscriber">
				<c path="flash.net.NetStream"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</onPeerConnect>
		<pause public="1" set="method"><f a=""><x path="Void"/></f></pause>
		<play public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></play>
		<play2 public="1" set="method">
			<f a="param">
				<c path="flash.net.NetStreamPlayOptions"/>
				<x path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</play2>
		<publish public="1" set="method"><f a="?name:?type">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></publish>
		<receiveAudio public="1" set="method"><f a="flag">
	<x path="Bool"/>
	<x path="Void"/>
</f></receiveAudio>
		<receiveVideo public="1" set="method"><f a="flag">
	<x path="Bool"/>
	<x path="Void"/>
</f></receiveVideo>
		<receiveVideoFPS public="1" set="method"><f a="FPS">
	<x path="Float"/>
	<x path="Void"/>
</f></receiveVideoFPS>
		<resume public="1" set="method"><f a=""><x path="Void"/></f></resume>
		<seek public="1" set="method"><f a="offset">
	<x path="Float"/>
	<x path="Void"/>
</f></seek>
		<send public="1" set="method"><f a="handlerName:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></send>
		<togglePause public="1" set="method"><f a=""><x path="Void"/></f></togglePause>
		<new public="1" set="method"><f a="connection:?peerID">
	<c path="flash.net.NetConnection"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.net.NetStreamInfo" params="" file="C:\HaxeToolkit\haxe\std/flash/net/NetStreamInfo.hx" extern="1">
		<SRTT public="1" set="null"><x path="Float"/></SRTT>
		<audioBufferByteLength public="1" set="null"><x path="Float"/></audioBufferByteLength>
		<audioBufferLength public="1" set="null"><x path="Float"/></audioBufferLength>
		<audioByteCount public="1" set="null"><x path="Float"/></audioByteCount>
		<audioBytesPerSecond public="1" set="null"><x path="Float"/></audioBytesPerSecond>
		<audioLossRate public="1" set="null"><x path="Float"/></audioLossRate>
		<byteCount public="1" set="null"><x path="Float"/></byteCount>
		<currentBytesPerSecond public="1" set="null"><x path="Float"/></currentBytesPerSecond>
		<dataBufferByteLength public="1" set="null"><x path="Float"/></dataBufferByteLength>
		<dataBufferLength public="1" set="null"><x path="Float"/></dataBufferLength>
		<dataByteCount public="1" set="null"><x path="Float"/></dataByteCount>
		<dataBytesPerSecond public="1" set="null"><x path="Float"/></dataBytesPerSecond>
		<droppedFrames public="1" set="null"><x path="Float"/></droppedFrames>
		<isLive public="1" set="null"><x path="Bool"/></isLive>
		<maxBytesPerSecond public="1" set="null"><x path="Float"/></maxBytesPerSecond>
		<metaData public="1" set="null"><d/></metaData>
		<playbackBytesPerSecond public="1" set="null"><x path="Float"/></playbackBytesPerSecond>
		<resourceName public="1" set="null"><c path="String"/></resourceName>
		<uri public="1" set="null"><c path="String"/></uri>
		<videoBufferByteLength public="1" set="null"><x path="Float"/></videoBufferByteLength>
		<videoBufferLength public="1" set="null"><x path="Float"/></videoBufferLength>
		<videoByteCount public="1" set="null"><x path="Float"/></videoByteCount>
		<videoBytesPerSecond public="1" set="null"><x path="Float"/></videoBytesPerSecond>
		<xmpData public="1" set="null"><d/></xmpData>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method"><f a="curBPS:byteCount:maxBPS:audioBPS:audioByteCount:videoBPS:videoByteCount:dataBPS:dataByteCount:playbackBPS:droppedFrames:audioBufferByteLength:videoBufferByteLength:dataBufferByteLength:audioBufferLength:videoBufferLength:dataBufferLength:srtt:audioLossRate:videoLossRate:?metaData:?xmpData:?uri:?resourceName:?isLive">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<d/>
	<d/>
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.net.NetStreamMulticastInfo" params="" file="C:\HaxeToolkit\haxe\std/flash/net/NetStreamMulticastInfo.hx" extern="1">
		<bytesPushedFromPeers public="1" set="null"><x path="Float"/></bytesPushedFromPeers>
		<bytesPushedToPeers public="1" set="null"><x path="Float"/></bytesPushedToPeers>
		<bytesReceivedFromIPMulticast public="1" set="null"><x path="Float"/></bytesReceivedFromIPMulticast>
		<bytesReceivedFromServer public="1" set="null"><x path="Float"/></bytesReceivedFromServer>
		<bytesRequestedByPeers public="1" set="null"><x path="Float"/></bytesRequestedByPeers>
		<bytesRequestedFromPeers public="1" set="null"><x path="Float"/></bytesRequestedFromPeers>
		<fragmentsPushedFromPeers public="1" set="null"><x path="Float"/></fragmentsPushedFromPeers>
		<fragmentsPushedToPeers public="1" set="null"><x path="Float"/></fragmentsPushedToPeers>
		<fragmentsReceivedFromIPMulticast public="1" set="null"><x path="Float"/></fragmentsReceivedFromIPMulticast>
		<fragmentsReceivedFromServer public="1" set="null"><x path="Float"/></fragmentsReceivedFromServer>
		<fragmentsRequestedByPeers public="1" set="null"><x path="Float"/></fragmentsRequestedByPeers>
		<fragmentsRequestedFromPeers public="1" set="null"><x path="Float"/></fragmentsRequestedFromPeers>
		<receiveControlBytesPerSecond public="1" set="null"><x path="Float"/></receiveControlBytesPerSecond>
		<receiveDataBytesPerSecond public="1" set="null"><x path="Float"/></receiveDataBytesPerSecond>
		<receiveDataBytesPerSecondFromIPMulticast public="1" set="null"><x path="Float"/></receiveDataBytesPerSecondFromIPMulticast>
		<receiveDataBytesPerSecondFromServer public="1" set="null"><x path="Float"/></receiveDataBytesPerSecondFromServer>
		<sendControlBytesPerSecond public="1" set="null"><x path="Float"/></sendControlBytesPerSecond>
		<sendControlBytesPerSecondToServer public="1" set="null"><x path="Float"/></sendControlBytesPerSecondToServer>
		<sendDataBytesPerSecond public="1" set="null"><x path="Float"/></sendDataBytesPerSecond>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1"><f a="sendDataBytesPerSecond:sendControlBytesPerSecond:receiveDataBytesPerSecond:receiveControlBytesPerSecond:bytesPushedToPeers:fragmentsPushedToPeers:bytesRequestedByPeers:fragmentsRequestedByPeers:bytesPushedFromPeers:fragmentsPushedFromPeers:bytesRequestedFromPeers:fragmentsRequestedFromPeers:sendControlBytesPerSecondToServer:receiveDataBytesPerSecondFromServer:bytesReceivedFromServer:fragmentsReceivedFromServer:receiveDataBytesPerSecondFromIPMulticast:bytesReceivedFromIPMulticast:fragmentsReceivedFromIPMulticast">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":final"/>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</class>
	<class path="flash.net.NetStreamPlayOptions" params="" file="C:\HaxeToolkit\haxe\std/flash/net/NetStreamPlayOptions.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<len public="1"><x path="Float"/></len>
		<oldStreamName public="1"><c path="String"/></oldStreamName>
		<start public="1"><x path="Float"/></start>
		<streamName public="1"><c path="String"/></streamName>
		<transition public="1"><c path="String"/></transition>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.net.Responder" params="" file="C:\HaxeToolkit\haxe\std/flash/net/Responder.hx" extern="1"><new public="1" set="method"><f a="result:?status">
	<d/>
	<d/>
	<x path="Void"/>
</f></new></class>
	<class path="flash.net.SharedObject" params="" file="C:\HaxeToolkit\haxe\std/flash/net/SharedObject.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<defaultObjectEncoding public="1" static="1"><x path="UInt"/></defaultObjectEncoding>
		<deleteAll public="1" set="method" static="1"><f a="url">
	<c path="String"/>
	<x path="Int"/>
</f></deleteAll>
		<getDiskUsage public="1" set="method" static="1"><f a="url">
	<c path="String"/>
	<x path="Int"/>
</f></getDiskUsage>
		<getLocal public="1" set="method" static="1"><f a="name:?localPath:?secure">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<c path="flash.net.SharedObject"/>
</f></getLocal>
		<getRemote public="1" set="method" static="1"><f a="name:?remotePath:?persistence:?secure">
	<c path="String"/>
	<c path="String"/>
	<d/>
	<x path="Bool"/>
	<c path="flash.net.SharedObject"/>
</f></getRemote>
		<client public="1"><d/></client>
		<data public="1" set="null"><d/></data>
		<fps public="1" get="null"><x path="Float"/></fps>
		<objectEncoding public="1"><x path="UInt"/></objectEncoding>
		<size public="1" set="null"><x path="UInt"/></size>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<connect public="1" set="method"><f a="myConnection:?params">
	<c path="flash.net.NetConnection"/>
	<c path="String"/>
	<x path="Void"/>
</f></connect>
		<flush public="1" set="method"><f a="?minDiskSpace">
	<x path="Int"/>
	<c path="String"/>
</f></flush>
		<send public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></send>
		<setDirty public="1" set="method"><f a="propertyName">
	<c path="String"/>
	<x path="Void"/>
</f></setDirty>
		<setProperty public="1" set="method"><f a="propertyName:?value">
	<c path="String"/>
	<t path="flash.utils.Object"/>
	<x path="Void"/>
</f></setProperty>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.utils.IDataInput" params="" file="C:\HaxeToolkit\haxe\std/flash/utils/IDataInput.hx" extern="1" interface="1">
		<bytesAvailable public="1" set="null"><x path="UInt"/></bytesAvailable>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<objectEncoding public="1"><x path="UInt"/></objectEncoding>
		<readBoolean public="1" set="method"><f a=""><x path="Bool"/></f></readBoolean>
		<readByte public="1" set="method"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></readBytes>
		<readDouble public="1" set="method"><f a=""><x path="Float"/></f></readDouble>
		<readFloat public="1" set="method"><f a=""><x path="Float"/></f></readFloat>
		<readInt public="1" set="method"><f a=""><x path="Int"/></f></readInt>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<x path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readShort public="1" set="method"><f a=""><x path="Int"/></f></readShort>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readUTFBytes public="1" set="method"><f a="length">
	<x path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUnsignedByte public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedByte>
		<readUnsignedInt public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedInt>
		<readUnsignedShort public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedShort>
	</class>
	<class path="flash.utils.IDataOutput" params="" file="C:\HaxeToolkit\haxe\std/flash/utils/IDataOutput.hx" extern="1" interface="1">
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<objectEncoding public="1"><x path="UInt"/></objectEncoding>
		<writeBoolean public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></writeBoolean>
		<writeByte public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></writeBytes>
		<writeDouble public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeDouble>
		<writeFloat public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writeInt public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></writeMultiByte>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<x path="Void"/>
</f></writeObject>
		<writeShort public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeShort>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTF>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTFBytes>
		<writeUnsignedInt public="1" set="method"><f a="value">
	<x path="UInt"/>
	<x path="Void"/>
</f></writeUnsignedInt>
	</class>
	<class path="flash.net.Socket" params="" file="C:\HaxeToolkit\haxe\std/flash/net/Socket.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<implements path="flash.utils.IDataInput"/>
		<implements path="flash.utils.IDataOutput"/>
		<bytesAvailable public="1" set="null"><x path="UInt"/></bytesAvailable>
		<connected public="1" set="null"><x path="Bool"/></connected>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<objectEncoding public="1"><x path="UInt"/></objectEncoding>
		<timeout public="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</timeout>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<connect public="1" set="method"><f a="host:port">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></connect>
		<flush public="1" set="method"><f a=""><x path="Void"/></f></flush>
		<readBoolean public="1" set="method"><f a=""><x path="Bool"/></f></readBoolean>
		<readByte public="1" set="method"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></readBytes>
		<readDouble public="1" set="method"><f a=""><x path="Float"/></f></readDouble>
		<readFloat public="1" set="method"><f a=""><x path="Float"/></f></readFloat>
		<readInt public="1" set="method"><f a=""><x path="Int"/></f></readInt>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<x path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readShort public="1" set="method"><f a=""><x path="Int"/></f></readShort>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readUTFBytes public="1" set="method"><f a="length">
	<x path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUnsignedByte public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedByte>
		<readUnsignedInt public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedInt>
		<readUnsignedShort public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedShort>
		<writeBoolean public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></writeBoolean>
		<writeByte public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></writeBytes>
		<writeDouble public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeDouble>
		<writeFloat public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writeInt public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></writeMultiByte>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<x path="Void"/>
</f></writeObject>
		<writeShort public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeShort>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTF>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTFBytes>
		<writeUnsignedInt public="1" set="method"><f a="value">
	<x path="UInt"/>
	<x path="Void"/>
</f></writeUnsignedInt>
		<new public="1" set="method"><f a="?host:?port">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.net.URLRequest" params="" file="C:\HaxeToolkit\haxe\std/flash/net/URLRequest.hx" extern="1">
		<contentType public="1"><c path="String"/></contentType>
		<data public="1"><d/></data>
		<digest public="1"><c path="String"/></digest>
		<method public="1"><c path="String"/></method>
		<requestHeaders public="1"><c path="Array"><c path="flash.net.URLRequestHeader"/></c></requestHeaders>
		<url public="1"><c path="String"/></url>
		<useRedirectedURL public="1" set="method"><f a="sourceRequest:?wholeURL:?pattern:?replace">
	<c path="flash.net.URLRequest"/>
	<x path="Bool"/>
	<d/>
	<c path="String"/>
	<x path="Void"/>
</f></useRedirectedURL>
		<new public="1" set="method"><f a="?url">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.net.URLRequestHeader" params="" file="C:\HaxeToolkit\haxe\std/flash/net/URLRequestHeader.hx" extern="1">
		<name public="1"><c path="String"/></name>
		<value public="1"><c path="String"/></value>
		<new public="1" set="method"><f a="?name:?value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.system.ApplicationDomain" params="" file="C:\HaxeToolkit\haxe\std/flash/system/ApplicationDomain.hx" extern="1">
		<MIN_DOMAIN_MEMORY_LENGTH public="1" set="null" static="1">
			<x path="UInt"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</MIN_DOMAIN_MEMORY_LENGTH>
		<currentDomain public="1" set="null" static="1"><c path="flash.system.ApplicationDomain"/></currentDomain>
		<domainMemory public="1">
			<c path="flash.utils.ByteArray"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</domainMemory>
		<parentDomain public="1" set="null"><c path="flash.system.ApplicationDomain"/></parentDomain>
		<getDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<t path="flash.utils.Object"/>
</f></getDefinition>
		<hasDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></hasDefinition>
		<new public="1" set="method"><f a="?parentDomain">
	<c path="flash.system.ApplicationDomain"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.system.ImageDecodingPolicy" params="" file="C:\HaxeToolkit\haxe\std/flash/system/ImageDecodingPolicy.hx">
		<ON_DEMAND/>
		<ON_LOAD/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.system.LoaderContext" params="" file="C:\HaxeToolkit\haxe\std/flash/system/LoaderContext.hx" extern="1">
		<applicationDomain public="1"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<checkPolicyFile public="1"><x path="Bool"/></checkPolicyFile>
		<securityDomain public="1"><c path="flash.system.SecurityDomain"/></securityDomain>
		<new public="1" set="method"><f a="?checkPolicyFile:?applicationDomain:?securityDomain">
	<x path="Bool"/>
	<c path="flash.system.ApplicationDomain"/>
	<c path="flash.system.SecurityDomain"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.system.Security" params="" file="C:\HaxeToolkit\haxe\std/flash/system/Security.hx" extern="1">
		<LOCAL_TRUSTED public="1" static="1"><c path="String"/></LOCAL_TRUSTED>
		<LOCAL_WITH_FILE public="1" static="1"><c path="String"/></LOCAL_WITH_FILE>
		<LOCAL_WITH_NETWORK public="1" static="1"><c path="String"/></LOCAL_WITH_NETWORK>
		<REMOTE public="1" static="1"><c path="String"/></REMOTE>
		<disableAVM1Loading public="1" static="1"><x path="Bool"/></disableAVM1Loading>
		<exactSettings public="1" static="1"><x path="Bool"/></exactSettings>
		<sandboxType public="1" set="null" static="1"><c path="String"/></sandboxType>
		<allowDomain public="1" set="method" static="1"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></allowDomain>
		<allowInsecureDomain public="1" set="method" static="1"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></allowInsecureDomain>
		<loadPolicyFile public="1" set="method" static="1"><f a="url">
	<c path="String"/>
	<x path="Void"/>
</f></loadPolicyFile>
		<showSettings public="1" set="method" static="1"><f a="?panel">
	<e path="flash.system.SecurityPanel"/>
	<x path="Void"/>
</f></showSettings>
	</class>
	<class path="flash.system.SecurityDomain" params="" file="C:\HaxeToolkit\haxe\std/flash/system/SecurityDomain.hx" extern="1"><currentDomain public="1" set="null" static="1"><c path="flash.system.SecurityDomain"/></currentDomain></class>
	<enum path="flash.system.SecurityPanel" params="" file="C:\HaxeToolkit\haxe\std/flash/system/SecurityPanel.hx">
		<CAMERA/>
		<DEFAULT/>
		<DISPLAY/>
		<LOCAL_STORAGE/>
		<MICROPHONE/>
		<PRIVACY/>
		<SETTINGS_MANAGER/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.text.AntiAliasType" params="" file="C:\HaxeToolkit\haxe\std/flash/text/AntiAliasType.hx">
		<ADVANCED/>
		<NORMAL/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.text.GridFitType" params="" file="C:\HaxeToolkit\haxe\std/flash/text/GridFitType.hx">
		<NONE/>
		<PIXEL/>
		<SUBPIXEL/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.text.StyleSheet" params="" file="C:\HaxeToolkit\haxe\std/flash/text/StyleSheet.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<styleNames public="1" set="null"><c path="Array"><d/></c></styleNames>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<getStyle public="1" set="method"><f a="styleName">
	<c path="String"/>
	<t path="flash.utils.Object"/>
</f></getStyle>
		<parseCSS public="1" set="method"><f a="CSSText">
	<c path="String"/>
	<x path="Void"/>
</f></parseCSS>
		<setStyle public="1" set="method"><f a="styleName:styleObject">
	<c path="String"/>
	<t path="flash.utils.Object"/>
	<x path="Void"/>
</f></setStyle>
		<transform public="1" set="method"><f a="formatObject">
	<t path="flash.utils.Object"/>
	<c path="flash.text.TextFormat"/>
</f></transform>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.text.TextField" params="" file="C:\HaxeToolkit\haxe\std/flash/text/TextField.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<isFontCompatible public="1" set="method" static="1">
			<f a="fontName:fontStyle">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</isFontCompatible>
		<alwaysShowSelection public="1"><x path="Bool"/></alwaysShowSelection>
		<antiAliasType public="1"><e path="flash.text.AntiAliasType"/></antiAliasType>
		<autoSize public="1"><e path="flash.text.TextFieldAutoSize"/></autoSize>
		<background public="1"><x path="Bool"/></background>
		<backgroundColor public="1"><x path="UInt"/></backgroundColor>
		<border public="1"><x path="Bool"/></border>
		<borderColor public="1"><x path="UInt"/></borderColor>
		<bottomScrollV public="1" set="null"><x path="Int"/></bottomScrollV>
		<caretIndex public="1" set="null"><x path="Int"/></caretIndex>
		<condenseWhite public="1"><x path="Bool"/></condenseWhite>
		<defaultTextFormat public="1"><c path="flash.text.TextFormat"/></defaultTextFormat>
		<displayAsPassword public="1"><x path="Bool"/></displayAsPassword>
		<embedFonts public="1"><x path="Bool"/></embedFonts>
		<gridFitType public="1"><e path="flash.text.GridFitType"/></gridFitType>
		<htmlText public="1"><c path="String"/></htmlText>
		<length public="1" set="null"><x path="Int"/></length>
		<maxChars public="1"><x path="Int"/></maxChars>
		<maxScrollH public="1" set="null"><x path="Int"/></maxScrollH>
		<maxScrollV public="1" set="null"><x path="Int"/></maxScrollV>
		<mouseWheelEnabled public="1"><x path="Bool"/></mouseWheelEnabled>
		<multiline public="1"><x path="Bool"/></multiline>
		<numLines public="1" set="null"><x path="Int"/></numLines>
		<restrict public="1"><c path="String"/></restrict>
		<scrollH public="1"><x path="Int"/></scrollH>
		<scrollV public="1"><x path="Int"/></scrollV>
		<selectable public="1"><x path="Bool"/></selectable>
		<selectedText public="1" set="null"><c path="String"/></selectedText>
		<selectionBeginIndex public="1" set="null"><x path="Int"/></selectionBeginIndex>
		<selectionEndIndex public="1" set="null"><x path="Int"/></selectionEndIndex>
		<sharpness public="1"><x path="Float"/></sharpness>
		<styleSheet public="1"><c path="flash.text.StyleSheet"/></styleSheet>
		<text public="1"><c path="String"/></text>
		<textColor public="1"><x path="UInt"/></textColor>
		<textHeight public="1" set="null"><x path="Float"/></textHeight>
		<textWidth public="1" set="null"><x path="Float"/></textWidth>
		<thickness public="1"><x path="Float"/></thickness>
		<type public="1"><e path="flash.text.TextFieldType"/></type>
		<useRichTextClipboard public="1"><x path="Bool"/></useRichTextClipboard>
		<wordWrap public="1"><x path="Bool"/></wordWrap>
		<appendText public="1" set="method"><f a="newText">
	<c path="String"/>
	<x path="Void"/>
</f></appendText>
		<copyRichText public="1" set="method"><f a=""><c path="String"/></f></copyRichText>
		<getCharBoundaries public="1" set="method"><f a="charIndex">
	<x path="Int"/>
	<c path="flash.geom.Rectangle"/>
</f></getCharBoundaries>
		<getCharIndexAtPoint public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></getCharIndexAtPoint>
		<getFirstCharInParagraph public="1" set="method"><f a="charIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getFirstCharInParagraph>
		<getImageReference public="1" set="method"><f a="id">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getImageReference>
		<getLineIndexAtPoint public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></getLineIndexAtPoint>
		<getLineIndexOfChar public="1" set="method"><f a="charIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getLineIndexOfChar>
		<getLineLength public="1" set="method"><f a="lineIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getLineLength>
		<getLineMetrics public="1" set="method"><f a="lineIndex">
	<x path="Int"/>
	<c path="flash.text.TextLineMetrics"/>
</f></getLineMetrics>
		<getLineOffset public="1" set="method"><f a="lineIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getLineOffset>
		<getLineText public="1" set="method"><f a="lineIndex">
	<x path="Int"/>
	<c path="String"/>
</f></getLineText>
		<getParagraphLength public="1" set="method"><f a="charIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getParagraphLength>
		<getRawText public="1" set="method"><f a=""><c path="String"/></f></getRawText>
		<getTextFormat public="1" set="method"><f a="?beginIndex:?endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<c path="flash.text.TextFormat"/>
</f></getTextFormat>
		<getTextRuns public="1" set="method"><f a="?beginIndex:?endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><d/></c>
</f></getTextRuns>
		<getXMLText public="1" set="method"><f a="?beginIndex:?endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></getXMLText>
		<insertXMLText public="1" set="method"><f a="beginIndex:endIndex:richText:?pasting">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></insertXMLText>
		<pasteRichText public="1" set="method"><f a="richText">
	<c path="String"/>
	<x path="Bool"/>
</f></pasteRichText>
		<replaceSelectedText public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></replaceSelectedText>
		<replaceText public="1" set="method"><f a="beginIndex:endIndex:newText">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></replaceText>
		<setSelection public="1" set="method"><f a="beginIndex:endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setSelection>
		<setTextFormat public="1" set="method"><f a="format:?beginIndex:?endIndex">
	<c path="flash.text.TextFormat"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setTextFormat>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<enum path="flash.text.TextFieldAutoSize" params="" file="C:\HaxeToolkit\haxe\std/flash/text/TextFieldAutoSize.hx">
		<CENTER/>
		<LEFT/>
		<NONE/>
		<RIGHT/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.text.TextFieldType" params="" file="C:\HaxeToolkit\haxe\std/flash/text/TextFieldType.hx">
		<DYNAMIC/>
		<INPUT/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.text.TextFormat" params="" file="C:\HaxeToolkit\haxe\std/flash/text/TextFormat.hx" extern="1">
		<align public="1"><e path="flash.text.TextFormatAlign"/></align>
		<blockIndent public="1"><t path="Null"><x path="Float"/></t></blockIndent>
		<bold public="1"><t path="Null"><x path="Bool"/></t></bold>
		<bullet public="1"><t path="Null"><x path="Bool"/></t></bullet>
		<color public="1"><t path="Null"><x path="UInt"/></t></color>
		<display public="1"><e path="flash.text.TextFormatDisplay"/></display>
		<font public="1"><c path="String"/></font>
		<indent public="1"><t path="Null"><x path="Float"/></t></indent>
		<italic public="1"><t path="Null"><x path="Bool"/></t></italic>
		<kerning public="1"><t path="Null"><x path="Bool"/></t></kerning>
		<leading public="1"><t path="Null"><x path="Float"/></t></leading>
		<leftMargin public="1"><t path="Null"><x path="Float"/></t></leftMargin>
		<letterSpacing public="1"><t path="Null"><x path="Float"/></t></letterSpacing>
		<rightMargin public="1"><t path="Null"><x path="Float"/></t></rightMargin>
		<size public="1"><t path="Null"><x path="Float"/></t></size>
		<tabStops public="1"><c path="Array"><x path="UInt"/></c></tabStops>
		<target public="1"><c path="String"/></target>
		<underline public="1"><t path="Null"><x path="Bool"/></t></underline>
		<url public="1"><c path="String"/></url>
		<new public="1" set="method"><f a="?font:?size:?color:?bold:?italic:?underline:?url:?target:?align:?leftMargin:?rightMargin:?indent:?leading">
	<c path="String"/>
	<x path="Float"/>
	<x path="UInt"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="String"/>
	<c path="String"/>
	<e path="flash.text.TextFormatAlign"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="flash.text.TextFormatAlign" params="" file="C:\HaxeToolkit\haxe\std/flash/text/TextFormatAlign.hx">
		<CENTER/>
		<END/>
		<JUSTIFY/>
		<LEFT/>
		<RIGHT/>
		<START/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.text.TextFormatDisplay" params="" file="C:\HaxeToolkit\haxe\std/flash/text/TextFormatDisplay.hx">
		<BLOCK/>
		<INLINE/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.text.TextInteractionMode" params="" file="C:\HaxeToolkit\haxe\std/flash/text/TextInteractionMode.hx">
		<NORMAL/>
		<SELECTION/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.text.TextLineMetrics" params="" file="C:\HaxeToolkit\haxe\std/flash/text/TextLineMetrics.hx" extern="1">
		<ascent public="1"><x path="Float"/></ascent>
		<descent public="1"><x path="Float"/></descent>
		<height public="1"><x path="Float"/></height>
		<leading public="1"><x path="Float"/></leading>
		<width public="1"><x path="Float"/></width>
		<x public="1"><x path="Float"/></x>
		<new public="1" set="method"><f a="x:width:height:ascent:descent:leading">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.text.TextSnapshot" params="" file="C:\HaxeToolkit\haxe\std/flash/text/TextSnapshot.hx" extern="1">
		<charCount public="1" set="null"><x path="Int"/></charCount>
		<findText public="1" set="method"><f a="beginIndex:textToFind:caseSensitive">
	<x path="Int"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></findText>
		<getSelected public="1" set="method"><f a="beginIndex:endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></getSelected>
		<getSelectedText public="1" set="method"><f a="?includeLineEndings">
	<x path="Bool"/>
	<c path="String"/>
</f></getSelectedText>
		<getText public="1" set="method"><f a="beginIndex:endIndex:?includeLineEndings">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<c path="String"/>
</f></getText>
		<getTextRunInfo public="1" set="method"><f a="beginIndex:endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><d/></c>
</f></getTextRunInfo>
		<hitTestTextNearPos public="1" set="method"><f a="x:y:?maxDistance">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></hitTestTextNearPos>
		<setSelectColor public="1" set="method"><f a="?hexColor">
	<x path="UInt"/>
	<x path="Void"/>
</f></setSelectColor>
		<setSelected public="1" set="method"><f a="beginIndex:endIndex:select">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setSelected>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.ui.ContextMenu" params="" file="C:\HaxeToolkit\haxe\std/flash/ui/ContextMenu.hx" extern="1">
		<extends path="flash.display.NativeMenu"/>
		<builtInItems public="1"><c path="flash.ui.ContextMenuBuiltInItems"/></builtInItems>
		<clipboardItems public="1">
			<c path="flash.ui.ContextMenuClipboardItems"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</clipboardItems>
		<clipboardMenu public="1">
			<x path="Bool"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</clipboardMenu>
		<customItems public="1"><c path="Array"><d/></c></customItems>
		<link public="1">
			<c path="flash.net.URLRequest"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</link>
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenu"/></f></clone>
		<hideBuiltInItems public="1" set="method"><f a=""><x path="Void"/></f></hideBuiltInItems>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.ui.ContextMenuBuiltInItems" params="" file="C:\HaxeToolkit\haxe\std/flash/ui/ContextMenuBuiltInItems.hx" extern="1">
		<forwardAndBack public="1"><x path="Bool"/></forwardAndBack>
		<loop public="1"><x path="Bool"/></loop>
		<play public="1"><x path="Bool"/></play>
		<print public="1"><x path="Bool"/></print>
		<quality public="1"><x path="Bool"/></quality>
		<rewind public="1"><x path="Bool"/></rewind>
		<save public="1"><x path="Bool"/></save>
		<zoom public="1"><x path="Bool"/></zoom>
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenuBuiltInItems"/></f></clone>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.ui.ContextMenuClipboardItems" params="" file="C:\HaxeToolkit\haxe\std/flash/ui/ContextMenuClipboardItems.hx" extern="1">
		<clear public="1"><x path="Bool"/></clear>
		<copy public="1"><x path="Bool"/></copy>
		<cut public="1"><x path="Bool"/></cut>
		<paste public="1"><x path="Bool"/></paste>
		<selectAll public="1"><x path="Bool"/></selectAll>
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenuClipboardItems"/></f></clone>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.ui.KeyLocation" params="" file="C:\HaxeToolkit\haxe\std/flash/ui/KeyLocation.hx">
		<D_PAD/>
		<LEFT/>
		<NUM_PAD/>
		<RIGHT/>
		<STANDARD/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>UInt</e></m>
		</meta>
	</enum>
	<class path="flash.ui.Keyboard" params="" file="C:\HaxeToolkit\haxe\std/flash/ui/Keyboard.hx" extern="1">
		<BACKSPACE public="1" static="1"><x path="UInt"/></BACKSPACE>
		<CAPS_LOCK public="1" static="1"><x path="UInt"/></CAPS_LOCK>
		<CONTROL public="1" static="1"><x path="UInt"/></CONTROL>
		<DELETE public="1" static="1"><x path="UInt"/></DELETE>
		<DOWN public="1" static="1"><x path="UInt"/></DOWN>
		<END public="1" static="1"><x path="UInt"/></END>
		<ENTER public="1" static="1"><x path="UInt"/></ENTER>
		<ESCAPE public="1" static="1"><x path="UInt"/></ESCAPE>
		<F1 public="1" static="1"><x path="UInt"/></F1>
		<F10 public="1" static="1"><x path="UInt"/></F10>
		<F11 public="1" static="1"><x path="UInt"/></F11>
		<F12 public="1" static="1"><x path="UInt"/></F12>
		<F13 public="1" static="1"><x path="UInt"/></F13>
		<F14 public="1" static="1"><x path="UInt"/></F14>
		<F15 public="1" static="1"><x path="UInt"/></F15>
		<F2 public="1" static="1"><x path="UInt"/></F2>
		<F3 public="1" static="1"><x path="UInt"/></F3>
		<F4 public="1" static="1"><x path="UInt"/></F4>
		<F5 public="1" static="1"><x path="UInt"/></F5>
		<F6 public="1" static="1"><x path="UInt"/></F6>
		<F7 public="1" static="1"><x path="UInt"/></F7>
		<F8 public="1" static="1"><x path="UInt"/></F8>
		<F9 public="1" static="1"><x path="UInt"/></F9>
		<HOME public="1" static="1"><x path="UInt"/></HOME>
		<INSERT public="1" static="1"><x path="UInt"/></INSERT>
		<LEFT public="1" static="1"><x path="UInt"/></LEFT>
		<NUMPAD_0 public="1" static="1"><x path="UInt"/></NUMPAD_0>
		<NUMPAD_1 public="1" static="1"><x path="UInt"/></NUMPAD_1>
		<NUMPAD_2 public="1" static="1"><x path="UInt"/></NUMPAD_2>
		<NUMPAD_3 public="1" static="1"><x path="UInt"/></NUMPAD_3>
		<NUMPAD_4 public="1" static="1"><x path="UInt"/></NUMPAD_4>
		<NUMPAD_5 public="1" static="1"><x path="UInt"/></NUMPAD_5>
		<NUMPAD_6 public="1" static="1"><x path="UInt"/></NUMPAD_6>
		<NUMPAD_7 public="1" static="1"><x path="UInt"/></NUMPAD_7>
		<NUMPAD_8 public="1" static="1"><x path="UInt"/></NUMPAD_8>
		<NUMPAD_9 public="1" static="1"><x path="UInt"/></NUMPAD_9>
		<NUMPAD_ADD public="1" static="1"><x path="UInt"/></NUMPAD_ADD>
		<NUMPAD_DECIMAL public="1" static="1"><x path="UInt"/></NUMPAD_DECIMAL>
		<NUMPAD_DIVIDE public="1" static="1"><x path="UInt"/></NUMPAD_DIVIDE>
		<NUMPAD_ENTER public="1" static="1"><x path="UInt"/></NUMPAD_ENTER>
		<NUMPAD_MULTIPLY public="1" static="1"><x path="UInt"/></NUMPAD_MULTIPLY>
		<NUMPAD_SUBTRACT public="1" static="1"><x path="UInt"/></NUMPAD_SUBTRACT>
		<PAGE_DOWN public="1" static="1"><x path="UInt"/></PAGE_DOWN>
		<PAGE_UP public="1" static="1"><x path="UInt"/></PAGE_UP>
		<RIGHT public="1" static="1"><x path="UInt"/></RIGHT>
		<SHIFT public="1" static="1"><x path="UInt"/></SHIFT>
		<SPACE public="1" static="1"><x path="UInt"/></SPACE>
		<TAB public="1" static="1"><x path="UInt"/></TAB>
		<UP public="1" static="1"><x path="UInt"/></UP>
		<capsLock public="1" set="null" static="1"><x path="Bool"/></capsLock>
		<numLock public="1" set="null" static="1"><x path="Bool"/></numLock>
		<isAccessible public="1" set="method" static="1"><f a=""><x path="Bool"/></f></isAccessible>
	</class>
	<enum path="flash.ui.KeyboardType" params="" file="C:\HaxeToolkit\haxe\std/flash/ui/KeyboardType.hx">
		<ALPHANUMERIC/>
		<KEYPAD/>
		<NONE/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.utils.IDataInput2" params="" file="C:\HaxeToolkit\haxe\std/flash/utils/IDataInput2.hx" extern="1" interface="1"><extends path="flash.utils.IDataInput"/></class>
	<class path="flash.utils.IDataOutput2" params="" file="C:\HaxeToolkit\haxe\std/flash/utils/IDataOutput2.hx" extern="1" interface="1"><extends path="flash.utils.IDataOutput"/></class>
	<class path="flash.utils.ByteArray" params="" file="C:\HaxeToolkit\haxe\std/flash/utils/ByteArray.hx" extern="1">
		<implements path="flash.utils.IDataInput2"/>
		<implements path="flash.utils.IDataOutput2"/>
		<defaultObjectEncoding public="1" static="1"><x path="UInt"/></defaultObjectEncoding>
		<bytesAvailable public="1" set="null"><x path="UInt"/></bytesAvailable>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<length public="1"><x path="UInt"/></length>
		<objectEncoding public="1"><x path="UInt"/></objectEncoding>
		<position public="1"><x path="UInt"/></position>
		<clear public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</clear>
		<compress public="1" set="method"><f a="?algorithm">
	<e path="flash.utils.CompressionAlgorithm"/>
	<x path="Void"/>
</f></compress>
		<deflate public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</deflate>
		<inflate public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</inflate>
		<readBoolean public="1" set="method"><f a=""><x path="Bool"/></f></readBoolean>
		<readByte public="1" set="method"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></readBytes>
		<readDouble public="1" set="method"><f a=""><x path="Float"/></f></readDouble>
		<readFloat public="1" set="method"><f a=""><x path="Float"/></f></readFloat>
		<readInt public="1" set="method"><f a=""><x path="Int"/></f></readInt>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<x path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readShort public="1" set="method"><f a=""><x path="Int"/></f></readShort>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readUTFBytes public="1" set="method"><f a="length">
	<x path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUnsignedByte public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedByte>
		<readUnsignedInt public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedInt>
		<readUnsignedShort public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedShort>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<uncompress public="1" set="method"><f a="?algorithm">
	<e path="flash.utils.CompressionAlgorithm"/>
	<x path="Void"/>
</f></uncompress>
		<writeBoolean public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></writeBoolean>
		<writeByte public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></writeBytes>
		<writeDouble public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeDouble>
		<writeFloat public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writeInt public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></writeMultiByte>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<x path="Void"/>
</f></writeObject>
		<writeShort public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeShort>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTF>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTFBytes>
		<writeUnsignedInt public="1" set="method"><f a="value">
	<x path="UInt"/>
	<x path="Void"/>
</f></writeUnsignedInt>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<enum path="flash.utils.CompressionAlgorithm" params="" file="C:\HaxeToolkit\haxe\std/flash/utils/CompressionAlgorithm.hx">
		<DEFLATE/>
		<LZMA/>
		<ZLIB/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash11</e></m>
		</meta>
	</enum>
	<class path="flash.utils.Dictionary" params="" file="C:\HaxeToolkit\haxe\std/flash/utils/Dictionary.hx" extern="1">
		<new public="1" set="method"><f a="?weakKeys">
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="flash.utils.Endian" params="" file="C:\HaxeToolkit\haxe\std/flash/utils/Endian.hx">
		<BIG_ENDIAN/>
		<LITTLE_ENDIAN/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<typedef path="flash.utils.Function" params="" file="C:\HaxeToolkit\haxe\std/flash/utils/Function.hx"><d/></typedef>
	<class path="flash.utils.Namespace" params="" file="C:\HaxeToolkit\haxe\std/flash/utils/Namespace.hx" extern="1">
		<prefix public="1" set="null"><d/></prefix>
		<uri public="1" set="null"><c path="String"/></uri>
		<new public="1" set="method"><f a="?prefix:?uri">
	<d/>
	<d/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<typedef path="flash.utils.Object" params="" file="C:\HaxeToolkit\haxe\std/flash/utils/Object.hx"><d/></typedef>
	<class path="flash.utils.RegExp" params="" file="C:\HaxeToolkit\haxe\std/flash/utils/RegExp.hx" extern="1">
		<dotall public="1" set="null"><x path="Bool"/></dotall>
		<extended public="1" set="null"><x path="Bool"/></extended>
		<global public="1" set="null"><x path="Bool"/></global>
		<ignoreCase public="1" set="null"><x path="Bool"/></ignoreCase>
		<lastIndex public="1"><x path="Int"/></lastIndex>
		<multiline public="1" set="null"><x path="Bool"/></multiline>
		<source public="1" set="null"><c path="String"/></source>
		<exec public="1" set="method">
			<f a="?s">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":ns"><e>"http://adobe.com/AS3/2006/builtin"</e></m></meta>
		</exec>
		<test public="1" set="method">
			<f a="?s">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":ns"><e>"http://adobe.com/AS3/2006/builtin"</e></m></meta>
		</test>
		<new public="1" set="method"><f a="?pattern:?options">
	<d/>
	<d/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"RegExp"</e></m></meta>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.xml.XML" params="" file="C:\HaxeToolkit\haxe\std/flash/xml/XML.hx" extern="1">
		<ignoreComments public="1" static="1"><x path="Bool"/></ignoreComments>
		<ignoreProcessingInstructions public="1" static="1"><x path="Bool"/></ignoreProcessingInstructions>
		<ignoreWhitespace public="1" static="1"><x path="Bool"/></ignoreWhitespace>
		<prettyIndent public="1" static="1"><x path="Int"/></prettyIndent>
		<prettyPrinting public="1" static="1"><x path="Bool"/></prettyPrinting>
		<defaultSettings public="1" set="method" static="1"><f a=""><d/></f></defaultSettings>
		<setSettings public="1" set="method" static="1"><f a="?o">
	<d/>
	<x path="Void"/>
</f></setSettings>
		<settings public="1" set="method" static="1"><f a=""><d/></f></settings>
		<addNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<appendChild public="1" set="method"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<attribute public="1" set="method"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<attributes public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<child public="1" set="method"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<childIndex public="1" set="method"><f a=""><x path="Int"/></f></childIndex>
		<children public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<comments public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<contains public="1" set="method"><f a="value">
	<d/>
	<x path="Bool"/>
</f></contains>
		<copy public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></copy>
		<descendants public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<elements public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<hasComplexContent public="1" set="method"><f a=""><x path="Bool"/></f></hasComplexContent>
		<hasSimpleContent public="1" set="method"><f a=""><x path="Bool"/></f></hasSimpleContent>
		<inScopeNamespaces public="1" set="method"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<insertChildAfter public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildAfter>
		<insertChildBefore public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildBefore>
		<length public="1" set="method"><f a=""><x path="Int"/></f></length>
		<localName public="1" set="method"><f a=""><t path="flash.utils.Object"/></f></localName>
		<name public="1" set="method"><f a=""><t path="flash.utils.Object"/></f></name>
		<namespace public="1" set="method"><f a="?prefix">
	<d/>
	<c path="flash.utils.Namespace"/>
</f></namespace>
		<namespaceDeclarations public="1" set="method"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<nodeKind public="1" set="method"><f a=""><c path="String"/></f></nodeKind>
		<normalize public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></normalize>
		<notification public="1" set="method"><f a=""><t path="flash.utils.Function"/></f></notification>
		<parent public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></parent>
		<prependChild public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<processingInstructions public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<removeNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<replace public="1" set="method"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<setChildren public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<setLocalName public="1" set="method"><f a="name">
	<d/>
	<x path="Void"/>
</f></setLocalName>
		<setName public="1" set="method"><f a="name">
	<d/>
	<x path="Void"/>
</f></setName>
		<setNamespace public="1" set="method"><f a="ns">
	<d/>
	<x path="Void"/>
</f></setNamespace>
		<setNotification public="1" set="method"><f a="f">
	<t path="flash.utils.Function"/>
	<d/>
</f></setNotification>
		<text public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<toXMLString public="1" set="method"><f a=""><c path="String"/></f></toXMLString>
		<valueOf public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></valueOf>
		<new public="1" set="method"><f a="?value">
	<d/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
		<haxe_dynamic><c path="flash.xml.XMLList"/></haxe_dynamic>
	</class>
	<class path="flash.xml.XMLList" params="" file="C:\HaxeToolkit\haxe\std/flash/xml/XMLList.hx" extern="1">
		<addNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<appendChild public="1" set="method"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<attribute public="1" set="method"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<attributes public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<child public="1" set="method"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<childIndex public="1" set="method"><f a=""><x path="Int"/></f></childIndex>
		<children public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<comments public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<contains public="1" set="method"><f a="value">
	<d/>
	<x path="Bool"/>
</f></contains>
		<copy public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></copy>
		<descendants public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<elements public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<hasComplexContent public="1" set="method"><f a=""><x path="Bool"/></f></hasComplexContent>
		<hasSimpleContent public="1" set="method"><f a=""><x path="Bool"/></f></hasSimpleContent>
		<inScopeNamespaces public="1" set="method"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<insertChildAfter public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildAfter>
		<insertChildBefore public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildBefore>
		<length public="1" set="method"><f a=""><x path="Int"/></f></length>
		<localName public="1" set="method"><f a=""><t path="flash.utils.Object"/></f></localName>
		<name public="1" set="method"><f a=""><t path="flash.utils.Object"/></f></name>
		<namespace public="1" set="method"><f a="?prefix">
	<d/>
	<c path="flash.utils.Namespace"/>
</f></namespace>
		<namespaceDeclarations public="1" set="method"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<nodeKind public="1" set="method"><f a=""><c path="String"/></f></nodeKind>
		<normalize public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></normalize>
		<parent public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></parent>
		<prependChild public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<processingInstructions public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<removeNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<replace public="1" set="method"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<setChildren public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<setLocalName public="1" set="method"><f a="name">
	<d/>
	<x path="Void"/>
</f></setLocalName>
		<setName public="1" set="method"><f a="name">
	<d/>
	<x path="Void"/>
</f></setName>
		<setNamespace public="1" set="method"><f a="ns">
	<d/>
	<x path="Void"/>
</f></setNamespace>
		<text public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<toXMLString public="1" set="method"><f a=""><c path="String"/></f></toXMLString>
		<valueOf public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></valueOf>
		<new public="1" set="method"><f a="?value">
	<d/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="haxe.EnumTools" params="" file="C:\HaxeToolkit\haxe\std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="41" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
			pack1.pack2.(...).packN.EnumName
		If `e` is a sub-type of a haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is null, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="54" static="1">
			<f a="e:constr:?params" v="::null">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="70" static="1">
			<f a="e:index:?params" v="::null">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="87" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array [] if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="99" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is null, the result is unspecified.</haxe_doc>
		</getConstructors>
	</class>
	<class path="haxe.EnumValueTools" params="" file="C:\HaxeToolkit\haxe\std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="114" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors, if exists.

		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="125" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is null, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="139" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is [].

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="151" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is null, the result is unspecified.</haxe_doc>
		</getIndex>
	</class>
	<class path="haxe.Log" params="" file="C:\HaxeToolkit\haxe\std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="45" static="1">
			<f a="v:?infos" v=":null">
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Outputs `v` in a platform-dependent way.

		The second parameter `infos` is injected by the compiler and contains
		information about the position where the trace() call was made.

		This method can be rebound to a custom function:
			var oldTrace = haxe.Log.trace; // store old function
			haxe.Log.trace = function(v,infos) { // handle trace }
			...
			haxe.Log.trace = oldTrace;

		If it is bound to null, subsequent calls to trace() will cause an
		exception.</haxe_doc>
		</trace>
		<haxe_doc>Log primarily provides the trace() method, which is invoked upon a call to
	trace() in haxe code.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<typedef path="haxe.PosInfos" params="" file="C:\HaxeToolkit\haxe\std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<c path="Array"><d/></c>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>PosInfos is a magic type which can be used to generate position information
	into the output for debugging use.

	If a function has a final optional argument of this type, i.e.
	(..., ?pos:haxe.PosInfos), each call to that function which does not assign
	a value to that argument has its position added as call argument.

	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<class path="haxe.Timer" params="" file="C:\HaxeToolkit\haxe\std/haxe/Timer.hx">
		<stamp public="1" set="method" line="161" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a timestamp, in seconds with fractions.

		The value itself might differ depending on platforms, only differences
		between two values make sense.</haxe_doc>
		</stamp>
		<haxe_doc>The Timer class allows you to create asynchronous timers on platforms that
	support events.

	The intended usage is to create an instance of the Timer class with a given
	interval, set its run() method to a custom function to be invoked and
	eventually call stop() to stop the Timer.

	Note that a running Timer may or may not prevent the program to exit
	automatically when main() returns.

	It is also possible to extend this class and override its run() method in
	the child class.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<abstract path="haxe.ds.HashMap" params="K:V" file="C:\HaxeToolkit\haxe\std/haxe/ds/HashMap.hx">
		<this><a>
	<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
	<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
</a></this>
		<impl><class path="haxe.ds._HashMap.HashMap_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/ds/HashMap.hx" private="1" module="haxe.ds.HashMap"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.ds.StringMap" params="T" file="C:\HaxeToolkit\haxe\std/flash/_std/haxe/ds/StringMap.hx">
		<implements path="IMap">
			<c path="String"/>
			<c path="haxe.ds.StringMap.T"/>
		</implements>
		<h><c path="flash.utils.Dictionary"/></h>
		<get public="1" set="method" line="36">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="haxe.ds.StringMap.T"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<keys public="1" set="method" line="51">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<haxe_doc>StringMap allows mapping of String keys to arbitrary values.

	See `Map` for documentation details.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.format.JsonParser" params="" file="C:\HaxeToolkit\haxe\std/haxe/format/JsonParser.hx">
		<str><c path="String"/></str>
		<pos><x path="Int"/></pos>
		<parseRec set="method" line="17"><f a=""><d/></f></parseRec>
		<parseString set="method" line="99"><f a=""><c path="String"/></f></parseString>
		<invalidChar set="method" line="202"><f a=""><x path="Void"/></f></invalidChar>
		<invalidNumber set="method" line="207"><f a="start">
	<x path="Int"/>
	<x path="Void"/>
</f></invalidNumber>
		<new set="method" line="12"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.format.JsonPrinter" params="" file="C:\HaxeToolkit\haxe\std/haxe/format/JsonPrinter.hx">
		<print public="1" set="method" line="5" static="1"><f a="o:?replacer:?space" v=":null:null">
	<d/>
	<f a=":">
		<d/>
		<d/>
		<d/>
	</f>
	<c path="String"/>
	<c path="String"/>
</f></print>
		<buf><c path="flash.utils.ByteArray"/></buf>
		<replacer><f a=":">
	<d/>
	<d/>
	<d/>
</f></replacer>
		<indent><c path="String"/></indent>
		<pretty><x path="Bool"/></pretty>
		<nind><x path="Int"/></nind>
		<write set="method" line="40"><f a="k:v">
	<d/>
	<d/>
	<x path="Void"/>
</f></write>
		<classString set="method" line="119"><f a="v">
	<d/>
	<x path="Void"/>
</f></classString>
		<fieldsString set="method" line="128"><f a="v:fields">
	<d/>
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></fieldsString>
		<quote set="method" line="153"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></quote>
		<new set="method" line="17"><f a="replacer:space">
	<f a=":">
		<d/>
		<d/>
		<d/>
	</f>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":keep"/></meta>
	</class>
</haxe>